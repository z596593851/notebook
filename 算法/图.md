[[?.旅行商问题]]
[[802.找到最终的安全状态]]
[[847. 访问所有节点的最短路径]]
[[789.逃脱阻碍者]]

## 一.存图方式
- 邻接矩阵：适用于边数较多的**「稠密图」**使用，当边数量接近点的数量的平方，即 m=n方时，可定义为**「稠密图」**。
- 邻接表：适用于边数较少的**「稀疏图」**使用，当边数量接近点的数量，即 m=n时，可定义为**「稀疏图」**。
### 邻接表
对于图：
![[Pasted image 20210820161320.png]]
他的邻接表表示为：
![[Pasted image 20210820161345.png]]
创建过程为：
![[Pasted image 20210820161439.png]]
![[Pasted image 20210820161445.png]]
![[Pasted image 20210820161450.png]]
![[Pasted image 20210820161455.png]]
![[Pasted image 20210820161500.png]]
![[Pasted image 20210820161506.png]]
![[Pasted image 20210820161511.png]]
![[Pasted image 20210820161545.png]]

## 二.单源最短路径
### Dijkstra
### Floyd
Floyd的核心算法为：
```java
for(int k = 1 ; k <= n - 1 ; k ++){
    for(int i = 1 ; i < m ; i ++){
        if(dis[v[i]] > dis[u[i]] + w[i])
            dis[v[i]] = dis[u[i]] + w[i];
    }
}
```
图共有 **n** 个顶点和 **m** 条边，**dis[]** 用来存储起点到各顶点的最短路径，**u[i] v[i]** 存储第 **i** 条边的起点和终点。

对于下图：
![[Pasted image 20210824152940.png]]

初始化：
![[Pasted image 20210824153035.png]]

外层第一次循环后：
![[Pasted image 20210824153054.png]]

外层第二次循环后：
![[Pasted image 20210824153759.png]]

第三次四次：
![[Pasted image 20210824154031.png]]

如果对于一个有向图 0->1->2->3->4，按(0-1)，(0-2)，(0-3)，(0-4)的顺序进行松弛，那么一轮外层循环就能完成。但如果按照相反的顺序，则需要进行4次。所以外层循环 k 的意义在于，*第 k 次循环至少可以找到从起点开始经过 k 条边所到达的点的最短路径*。