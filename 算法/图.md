[[?.旅行商问题]]
[[802.找到最终的安全状态]]
[[847. 访问所有节点的最短路径]]
[[789.逃脱阻碍者]]

## 一.存图方式
- 邻接矩阵：适用于边数较多的**「稠密图」**使用，当边数量接近点的数量的平方，即 m=n方时，可定义为**「稠密图」**。
- 邻接表：适用于边数较少的**「稀疏图」**使用，当边数量接近点的数量，即 m=n时，可定义为**「稀疏图」**。
### 邻接表
对于图：
![[Pasted image 20210820161320.png]]
他的邻接表表示为：
![[Pasted image 20210820161345.png]]
创建过程为：
![[Pasted image 20210820161439.png]]
![[Pasted image 20210820161445.png]]
![[Pasted image 20210820161450.png]]
![[Pasted image 20210820161455.png]]
![[Pasted image 20210820161500.png]]
![[Pasted image 20210820161506.png]]
![[Pasted image 20210820161511.png]]
![[Pasted image 20210820161545.png]]
构建邻接表：
```java
int n,m,i;
//u、v和w的数组大小要根据实际情况来设置，要比m的最大值要大1
int u[6],v[6],w[6];
//first和next的数组大小要根据实际情况来设置，要比n的最大值要大1
int first[5],next[5];
scanf("%d %d",&n,&m);
//初始化first数组下标1~n的值为-1，表示1~n顶点暂时都没有边
for(i=1;i<=n;i++)
    first[i]=-1;
for(i=1;i<=m;i++)
{
    scanf("%d %d %d",&u[i],&v[i],&w[i]);//读入每一条边
    //下面两句是关键啦
    next[i]=first[u[i]];
    first[u[i]]=i;
}
```
遍历邻接表：
```java
for(i=1;i<=n;i++){
    k=first[i];
    while(k!=-1){
        printf("%d %d %d\n",u[k],v[k],w[k]);
        k=next[k];
    }
}
```

## 二.单源最短路径
求图中两节点间的最短路径
### Dijkstra
Dijkstra算法可以求出任意两点之间的最短距离，用邻接矩阵dis存图：
```java
for (int k = 0; k < n; ++k){
    for (int i = 0; i < n; ++i){
        for (int j = 0; j < n; ++j){
            dis[i][j] = Math.min(dis[i][j], dis[i][k] + dis[k][j]);
        }
    }
}
```
### Floyd
Floyd算法可以求出从指定 i 节点到其他各节点的最短距离：
```java
for(int k = 1 ; k <= n - 1 ; k ++){
    for(int i = 1 ; i < m ; i ++){
        if(dis[v[i]] > dis[u[i]] + w[i])
            dis[v[i]] = dis[u[i]] + w[i];
    }
}
```
图共有 **n** 个顶点和 **m** 条边，**dis[]** 用来存储起点到各顶点 **i** 的最短路径，**u[i] v[i]** 存储第 **i** 条边的起点和终点。

对于下图：
![[Pasted image 20210824152940.png]]

初始化：
![[Pasted image 20210824153035.png]]

外层第一次循环后：
![[Pasted image 20210824153054.png]]

外层第二次循环后：
![[Pasted image 20210824153759.png]]

第三次四次：
![[Pasted image 20210824154031.png]]

如果对于一个有向图 0->1->2->3->4，按(0-1)，(0-2)，(0-3)，(0-4)的顺序进行松弛，那么一轮外层循环就能完成。但如果按照相反的顺序，则需要进行4次。所以外层循环 k 的意义在于，*第 k 次循环至少可以找到从起点开始经过 k 条边所到达的点的最短路径*。

[[743.网络延迟时间]]
对于有边数限制的最短路问题，也可以用Floyd求解：
[[787.K站中转内最便宜的航班]]

## 三、拓扑排序
[[802.找到最终的安全状态#解法二：拓扑排序]]