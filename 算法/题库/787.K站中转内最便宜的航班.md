## 题目
![[Pasted image 20210824154603.png]]
![[Pasted image 20210824154622.png]]
## 题解
从题面看就能知道，这是一类「有限制」的最短路问题。
「限制最多经过不超过 kk 个点」等价于「限制最多不超过 k + 1k+1 条边」，而解决「有边数限制的最短路问题」

### 解法一：Floyd
```java
class Solution {
    int N = 110, INF = 0x3f3f3f3f;
    int[][] g = new int[N][N];
    int[] dist = new int[N];
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                g[i][j] = i == j ? 0 : INF;
            }
        }
        for (int[] f : flights) {
            g[f[0]][f[1]] = f[2];
        }
        Arrays.fill(dist, INF);
        dist[src] = 0;
        for (int limit = 1; limit <= k+1; limit++) {
            int[] clone = dist.clone();
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    dist[j] = Math.min(dist[j], clone[i] + g[i][j]);
                }
            }
        }
        int ans = dist[dst];
        return ans > INF / 2 ? -1 : ans;
    }
}
```
为了保证第 k 次外循环只能找到最多经过 k 条边所能到达的最短路径，所以引入了
``int[] clone = dist.clone();``