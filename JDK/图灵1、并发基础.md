并发(concurrency)：同一时刻只能有一条指令执行->时间片轮询
并行(parallel)：同一时刻，有多条指令在多个处理器上同时执行

并发三特性：可见性、原子性、有序性

可见性原理：
![[Pasted image 20211221212331.png]]
线程结束时会把数据刷回主存
本地内存过期被淘汰后会从主存读数据

如何保证可见性：
- Thread.yield()：会释放时间片，此时保存上下文，等再次抢到时间片时，加载上下文，就会读到主存里最新的值
- volatile：storeLoad内存屏障->lock（jvm会在汇编层面在加载变量时加上lock前缀，lock不是内存屏障指令，但是有内存屏障功能，即将栈内存刷回主存，和使栈内存失效）
![[Pasted image 20211222200816.png]]
- 内存屏障UnsafeFactory.getUnsafe().storeFence()，原理同volitaile调用fence
- sychronized：底层也会调fence
- LockSupport.unpark(Thread.currentThread())，同上，也会调fence
- Thread.sleep()，同上

总结：java中保证可见性有两种办法，切换上下文和jvm层面的内存屏障

