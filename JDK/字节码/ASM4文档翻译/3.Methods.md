# 3.Methods
本章解释了如何使用核心 ASM API 生成和转换已编译的方法。
## 3.1.结构
在已编译的类中，方法代码存储为字节码指令序列。为了生成和转换类，了解这些指令并理解它们是如何工作的至关重要。
### 3.1.1.执行模型
在介绍字节码指令之前，有必要介绍一下 Java 虚拟机执行模型。如您所知，Java 代码是在线程内执行的。每个线程都有自己的执行栈，由帧组成。每个帧代表一个方法调用：每次调用一个方法时，都会在当前线程的执行堆栈上推送一个新帧。当方法返回时，无论是正常情况还是由于异常，都会从执行堆栈中弹出此帧，并在调用方法（其帧现在位于堆栈顶部）中继续执行。

每个帧包含两部分：**局部变量**部分和**操作数堆栈**部分。局部变量部分包含可以按随机顺序通过索引访问的变量。操作数堆栈部分，顾名思义，是字节码指令用作操作数的值堆栈。这意味着只能以后进先出的顺序访问此堆栈中的值。不要混淆操作数堆栈和线程的执行堆栈：执行堆栈中的每个帧都包含自己的操作数堆栈。

局部变量和操作数堆栈部分的大小取决于方法的代码。它在编译时计算并与字节码指令一起存储在编译类中。因此，对应于给定方法调用的所有帧具有相同的大小，但对应于不同方法的帧的局部变量和操作数堆栈部分可以具有不同的大小。
![[Pasted image 20211020213731.png]]
图 3.1 显示了一个包含 3 个帧的示例执行堆栈。第一帧包含 3 个局部变量，其操作数堆栈的最大大小为 4，并且包含两个值。第二帧包含 2 个局部变量和其操作数堆栈中的两个值。最后，在执行堆栈顶部的第三帧包含 4 个局部变量和两个操作数。

当它被创建时，一个帧用一个空堆栈初始化，它的局部变量用目标对象 this（对于非静态方法）和方法的参数初始化。例如，调用 a.equals(b) 方法会创建一个带有空堆栈的帧，并且前两个局部变量初始化为 a 和 b（其他局部变量未初始化）。

局部变量和操作数堆栈部分中的每个插槽都可以保存任何 Java 值，除了 long 和 double 值。这些值需要两个插槽。这使局部变量的管理变得复杂：例如，第 i 个方法参数不一定存储在局部变量 i 中。例如，调用 Math.max(1L, 2L) 创建一个帧，在前两个局部变量槽中具有 1L 值，在第三和第四槽中具有值 2L。

### 3.1.2.字节码指令
字节码指令由标识该指令的**操作码**和固定数量的**参数**组成：

- 操作码 是一个无符号字节值——因此是字节码名称——并由助记符标识。例如操作码值 0 是由助记符 NOP 设计的，对应于什么都不做的指令。
- 参数是定义精确指令行为的静态值。它们在操作码之后给出。例如，操作码值为 167 的 GOTO 标签指令采用标签作为参数，该标签指定要执行的下一条指令。指令参数不能与指令操作数混淆：参数值是静态已知的并存储在编译代码中，而操作数值来自操作数堆栈并且仅在运行时已知。

字节码指令可以分为两类：一小组指令用于将值从局部变量传输到操作数堆栈，或者相反；其他指令仅作用于操作数堆栈：它们从堆栈中弹出一些值，根据这些值计算结果，并将其压回到堆栈上。

ILOAD、LLOAD、FLOAD、DLOAD 和 ALOAD 指令读取局部变量并将其值压入操作数堆栈。它们将必须读取的局部变量的索引 i 作为参数。 ILOAD 用于加载 boolean、byte、char、short 或 int 局部变量。 LLOAD、FLOAD 和 DLOAD 分别用于加载 long、float 或 double 值（LLOAD 和 DLOAD 实际上加载了两个插槽， i 和 i + 1）。最后 ALOAD 用于加载任何非原始值，即对象和数组引用。 

ISTORE、LSTORE、FSTORE、DSTORE 和 ASTORE 指令对称地从操作数堆栈中弹出一个值并将其存储在由其索引 i 指定的局部变量中。

实际上，将值存储在局部变量中然后用不同的类型加载它是非法的。例如，ISTORE 1 ALOAD 1 序列是非法的——它允许在局部变量 1 中存储任意内存地址，并将该地址转换为对象引用！然而，在局部变量中存储类型与存储在该局部变量中的当前值类型不同的值是完全合法的。这意味着局部变量的类型，即存储在该局部变量中的值的类型，可以在方法执行期间改变。

如上所述，所有其他字节码指令仅适用于操作数堆栈。它们可以分为以下几类：
- 栈指令：这些指令用于操作堆栈上的值：POP-弹出堆栈顶部的值，DUP-压入堆栈顶部值的副本，SWAP-弹出两个值并以相反的顺序压入它们，等等。
- 常量指令：这些指令将常量值压入操作数堆栈：ACONST_NULL 压入空值，ICONST_0 压入 int 值 0，FCONST_0 压入 0f，DCONST_0 压入 0d，BIPUSH b 压入字节值 b，SIPUSH s 压入 shot 值 s，LDC cst 压入 任意 int、float、long、double、String 或 class1、常量 cst 等。
- 算术和逻辑指令：这些指令从操作数堆栈中弹出数值，并将组合后的结果压入堆栈。xADD、xSUB、xMUL、xDIV 和 xREM 对应于 +、-、\*、/ 和 % 操作，其中 x 是 I、L、F 或 D。类似地，还有其他指令对应于 <‌<、>‌>， >‌>‌>、|、& 和 ^，用于 int 和 long 值。
- 转换指令：这些指令从堆栈中弹出一个值，将其转换为另一种类型，并将结果推回。 它们对应于 Java 中的强制转换表达式。 I2F、F2D、L2D 等将数值从一种数值类型转换为另一种数值类型。 CHECKCAST t 将引用值转换为类型 t。
- 对象指令：这些指令用于创建对象、锁定它们、检查它们的类型等。例如，NEW type 指令将类型为 type 的新对象压入堆栈（其中 type 是内部名称）。
- 字段指令：这些指令读取或写入字段的值。 GETFIELD owner name desc 弹出一个对象引用，并压入其 name 字段的值。 PUTFIELD owner name desc 弹出一个值和一个对象引用，并将该值存储在其名称字段中。 在这两种情况下，对象都必须是 owner 类型，并且它的字段必须是 desc 类型。 GETSTATIC 和 PUTSTATIC 是类似的指令，但用于静态字段。
- 方法指令：这些指令调用方法或构造函数。 它们弹出与方法参数一样多的值，以及一个代表目标对象的值，并压入方法调用的结果。 INVOKEVIRTUAL owner name desc 调用类owner 中定义的name 方法，其方法描述符为desc。 INVOKESTATIC 用于静态方法，INVOKESPECIAL 用于私有方法和构造函数，INVOKEINTERFACE 用于接口中定义的方法。 最后，对于 Java 7 中的类，INVOKEDYNAMIC 用于新的动态方法调用机制。
- 数组指令：这些指令用于读取和写入数组中的值。 xALOAD 指令弹出一个索引和一个数组，并压入数组在索引处的值。 xASTORE 指令弹出一个值、一个索引和一个数组，并将这个值存储在数组中的那个索引处。 这里 x 可以是 I、L、F、D 或 A，也可以是 B、C 或 S。
- 跳转指令：如果某些条件为真或无条件为真，这些指令将跳转到任意指令。 它们用于编译 if、for、do、while、break 和 continue 指令。 例如，IFEQ label 从堆栈中弹出一个 int 值，如果该值为 0，则跳转到 label 指令（否则继续正常执行到下一条指令）。 存在许多其他跳转指令，例如 IFNE 或 IFGE。 最后 TABLESWITCH 和 LOOKUPSWITCH 对应的是 switch 指令。
- 返回指令：最后，xRETURN 和 RETURN 指令用于终止方法的执行并将其结果返回给调用者。 RETURN 用于返回 void 的方法，而 xRETURN 用于其他方法。
### 实例
![[Pasted image 20211020224621.png]]
看一下getter方法的字节码：
![[Pasted image 20211020224648.png]]
在方法调用时，帧被创建，与此同时 this 也被初始化在了局部变量中。所以第一步是读取局部变量0到操作数栈中；第二条指令从堆栈中弹出这个值，即 this，并压入这个对象的 f 字段，即 this.f。 最后一条指令从堆栈中弹出这个值，并将其返回给调用者。 该方法的执行帧的连续状态如图 3.2 所示。
![[Pasted image 20211020231743.png]]
在看一下setter方法的字节码：
![[Pasted image 20211020232018.png]]
第一条指令像以前一样将 this 压入操作数堆栈。 第二条指令压入局部变量 1，该变量在该方法调用时创建帧期间，使用 f 参数值进行初始化。 第三条指令弹出这两个值并将 int 值存储在引用对象的 f 字段中，即在 this.f 中。 最后一条指令，在源代码中是隐藏的，但在编译代码中是强制性的，它终止当前的执行帧并返回给调用者。 该方法的执行帧的连续状态如图 3.3 所示。
![[Pasted image 20211020232343.png]]
Bean 类还有一个默认的公共构造函数，它由编译器生成，因为程序员没有定义显式构造函数。 这个默认的公共构造函数生成为 Bean() { super(); }. 此构造函数的字节码如下：
![[Pasted image 20211020232516.png]]
![[Pasted image 20211020232530.png]]
第一条指令将其压入操作数堆栈。 第二条指令从堆栈中弹出这个值，并调用 Object 类中定义的 init 方法。 这对应于 super() 调用，即对超类 Object 的构造函数的调用。 您可以在此处看到构造函数在编译类和源类中的命名不同：在编译类中，它们始终命名为 init，而在源类中，它们具有定义它们的类的名称。 最后最后一条指令返回给调用者。
现在让我们考虑一个稍微复杂的方法:
![[Pasted image 20211020232843.png]]
他的字节码如下所示：
![[Pasted image 20211020232904.png]]
![[Pasted image 20211020232914.png]]
第一条指令将初始化为 f 的局部变量 1 压入操作数堆栈。 IFLT 指令将该值从堆栈中弹出，并与 0 进行比较。如果小于 (LT) 0，则跳转到 label 标签指定的指令，否则不执行任何操作，继续执行下一条指令。接下来的三个指令与 setF 方法中的指令相同。 GOTO 指令无条件跳转到 end 标签指定的指令，即RETURN 指令。label 和 end 标签之间的指令创建并抛出异常：NEW 指令创建一个异常对象并将其压入操作数堆栈。 DUP 指令在堆栈上复制此值。 INVOKESPECIAL 指令弹出这两个副本之一并在其上调用异常构造函数。最后，ATHROW 指令弹出剩余的副本并将其作为异常抛出（因此不会继续执行下一条指令）。
