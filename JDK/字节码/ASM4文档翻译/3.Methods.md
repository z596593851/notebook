# 3.Methods
本章解释了如何使用核心 ASM API 生成和转换已编译的方法。
## 3.1.结构
在已编译的类中，方法代码存储为字节码指令序列。为了生成和转换类，了解这些指令并理解它们是如何工作的至关重要。
### 3.1.1.执行模型
在介绍字节码指令之前，有必要介绍一下 Java 虚拟机执行模型。如您所知，Java 代码是在线程内执行的。每个线程都有自己的执行栈，由帧组成。每个帧代表一个方法调用：每次调用一个方法时，都会在当前线程的执行堆栈上推送一个新帧。当方法返回时，无论是正常情况还是由于异常，都会从执行堆栈中弹出此帧，并在调用方法（其帧现在位于堆栈顶部）中继续执行。

每个帧包含两部分：**局部变量**部分和**操作数堆栈**部分。局部变量部分包含可以按随机顺序通过索引访问的变量。操作数堆栈部分，顾名思义，是字节码指令用作操作数的值堆栈。这意味着只能以后进先出的顺序访问此堆栈中的值。不要混淆操作数堆栈和线程的执行堆栈：执行堆栈中的每个帧都包含自己的操作数堆栈。

局部变量和操作数堆栈部分的大小取决于方法的代码。它在编译时计算并与字节码指令一起存储在编译类中。因此，对应于给定方法调用的所有帧具有相同的大小，但对应于不同方法的帧的局部变量和操作数堆栈部分可以具有不同的大小。
![[Pasted image 20211020213731.png]]
图 3.1 显示了一个包含 3 个帧的示例执行堆栈。第一帧包含 3 个局部变量，其操作数堆栈的最大大小为 4，并且包含两个值。第二帧包含 2 个局部变量和其操作数堆栈中的两个值。最后，在执行堆栈顶部的第三帧包含 4 个局部变量和两个操作数。

当它被创建时，一个帧用一个空堆栈初始化，它的局部变量用目标对象 this（对于非静态方法）和方法的参数初始化。例如，调用 a.equals(b) 方法会创建一个带有空堆栈的帧，并且前两个局部变量初始化为 a 和 b（其他局部变量未初始化）。

局部变量和操作数堆栈部分中的每个插槽都可以保存任何 Java 值，除了 long 和 double 值。这些值需要两个插槽。这使局部变量的管理变得复杂：例如，第 i 个方法参数不一定存储在局部变量 i 中。例如，调用 Math.max(1L, 2L) 创建一个帧，在前两个局部变量槽中具有 1L 值，在第三和第四槽中具有值 2L。

### 3.1.2.字节码指令
字节码指令由标识该指令的**操作码**和固定数量的**参数**组成：

- 操作码 是一个无符号字节值——因此是字节码名称——并由助记符标识。例如操作码值 0 是由助记符 NOP 设计的，对应于什么都不做的指令。
- 参数是定义精确指令行为的静态值。它们在操作码之后给出。例如，操作码值为 167 的 GOTO 标签指令采用标签作为参数，该标签指定要执行的下一条指令。指令参数不能与指令操作数混淆：参数值是静态已知的并存储在编译代码中，而操作数值来自操作数堆栈并且仅在运行时已知。

字节码指令可以分为两类：一小组指令用于将值从局部变量传输到操作数堆栈，或者相反；其他指令仅作用于操作数堆栈：它们从堆栈中弹出一些值，根据这些值计算结果，并将其压回到堆栈上。

ILOAD、LLOAD、FLOAD、DLOAD 和 ALOAD 指令读取局部变量并将其值压入操作数堆栈。它们将必须读取的局部变量的索引 i 作为参数。 ILOAD 用于加载 boolean、byte、char、short 或 int 局部变量。 LLOAD、FLOAD 和 DLOAD 分别用于加载 long、float 或 double 值（LLOAD 和 DLOAD 实际上加载了两个插槽， i 和 i + 1）。最后 ALOAD 用于加载任何非原始值，即对象和数组引用。 

ISTORE、LSTORE、FSTORE、DSTORE 和 ASTORE 指令对称地从操作数堆栈中弹出一个值并将其存储在由其索引 i 指定的局部变量中。

实际上，将值存储在局部变量中然后用不同的类型加载它是非法的。例如，ISTORE 1 ALOAD 1 序列是非法的——它允许在局部变量 1 中存储任意内存地址，并将该地址转换为对象引用！然而，在局部变量中存储类型与存储在该局部变量中的当前值类型不同的值是完全合法的。这意味着局部变量的类型，即存储在该局部变量中的值的类型，可以在方法执行期间改变。

如上所述，所有其他字节码指令仅适用于操作数堆栈。它们可以分为以下几类：
- 栈指令：这些指令用于操作堆栈上的值：POP-弹出堆栈顶部的值，DUP-压入堆栈顶部值的副本，SWAP-弹出两个值并以相反的顺序压入它们，等等。
- 常量指令：这些指令将常量值压入操作数堆栈：ACONST_NULL 压入空值，ICONST_0 压入 int 值 0，FCONST_0 压入 0f，DCONST_0 压入 0d，BIPUSH b 压入字节值 b，SIPUSH s 压入 shot 值 s，LDC cst 压入 任意 int、float、long、double、String 或 class1、常量 cst 等。
- 算术和逻辑指令：这些指令从操作数堆栈中弹出数值，并将组合后的结果压入堆栈。xADD、xSUB、xMUL、xDIV 和 xREM 对应于 +、-、\*、/ 和 % 操作，其中 x 是 I、L、F 或 D。类似地，还有其他指令对应于 <‌<、>‌>， >‌>‌>、|、& 和 ^，用于 int 和 long 值。
- 转换指令：这些指令从堆栈中弹出一个值，将其转换为另一种类型，并将结果推回。 它们对应于 Java 中的强制转换表达式。 I2F、F2D、L2D 等将数值从一种数值类型转换为另一种数值类型。 CHECKCAST t 将引用值转换为类型 t。
- 对象指令：这些指令用于创建对象、锁定它们、检查它们的类型等。例如，NEW type 指令将类型为 type 的新对象压入堆栈（其中 type 是内部名称）。
- 字段指令：这些指令读取或写入字段的值。 GETFIELD owner name desc 弹出一个对象引用，并压入其 name 字段的值。 PUTFIELD owner name desc 弹出一个值和一个对象引用，并将该值存储在其名称字段中。 在这两种情况下，对象都必须是 owner 类型，并且它的字段必须是 desc 类型。 GETSTATIC 和 PUTSTATIC 是类似的指令，但用于静态字段。
- 方法指令：这些指令调用方法或构造函数。 它们弹出与方法参数一样多的值，以及一个代表目标对象的值，并压入方法调用的结果。 INVOKEVIRTUAL owner name desc 调用类owner 中定义的name 方法，其方法描述符为desc。 INVOKESTATIC 用于静态方法，INVOKESPECIAL 用于私有方法和构造函数，INVOKEINTERFACE 用于接口中定义的方法。 最后，对于 Java 7 中的类，INVOKEDYNAMIC 用于新的动态方法调用机制。
- 数组指令：这些指令用于读取和写入数组中的值。 xALOAD 指令弹出一个索引和一个数组，并压入数组在索引处的值。 xASTORE 指令弹出一个值、一个索引和一个数组，并将这个值存储在数组中的那个索引处。 这里 x 可以是 I、L、F、D 或 A，也可以是 B、C 或 S。
- 跳转指令：如果某些条件为真或无条件为真，这些指令将跳转到任意指令。 它们用于编译 if、for、do、while、break 和 continue 指令。 例如，IFEQ label 从堆栈中弹出一个 int 值，如果该值为 0，则跳转到 label 指令（否则继续正常执行到下一条指令）。 存在许多其他跳转指令，例如 IFNE 或 IFGE。 最后 TABLESWITCH 和 LOOKUPSWITCH 对应的是 switch 指令。
- 返回指令：最后，xRETURN 和 RETURN 指令用于终止方法的执行并将其结果返回给调用者。 RETURN 用于返回 void 的方法，而 xRETURN 用于其他方法。
### 3.1.3 实例
![[Pasted image 20211020224621.png]]
看一下getter方法的字节码：
![[Pasted image 20211020224648.png]]
在方法调用时，帧被创建，与此同时 this 也被初始化在了局部变量中。所以第一步是读取局部变量0到操作数栈中；第二条指令从堆栈中弹出这个值，即 this，并压入这个对象的 f 字段，即 this.f。 最后一条指令从堆栈中弹出这个值，并将其返回给调用者。 该方法的执行帧的连续状态如图 3.2 所示。
![[Pasted image 20211020231743.png]]
在看一下setter方法的字节码：
![[Pasted image 20211020232018.png]]
第一条指令像以前一样将 this 压入操作数堆栈。 第二条指令压入局部变量 1，该变量在该方法调用时创建帧期间，使用 f 参数值进行初始化。 第三条指令弹出这两个值并将 int 值存储在引用对象的 f 字段中，即在 this.f 中。 最后一条指令，在源代码中是隐藏的，但在编译代码中是强制性的，它终止当前的执行帧并返回给调用者。 该方法的执行帧的连续状态如图 3.3 所示。
![[Pasted image 20211020232343.png]]
Bean 类还有一个默认的公共构造函数，它由编译器生成，因为程序员没有定义显式构造函数。 这个默认的公共构造函数生成为 Bean() { super(); }. 此构造函数的字节码如下：
![[Pasted image 20211020232516.png]]
![[Pasted image 20211020232530.png]]
第一条指令将其压入操作数堆栈。 第二条指令从堆栈中弹出这个值，并调用 Object 类中定义的 init 方法。 这对应于 super() 调用，即对超类 Object 的构造函数的调用。 您可以在此处看到构造函数在编译类和源类中的命名不同：在编译类中，它们始终命名为 init，而在源类中，它们具有定义它们的类的名称。 最后最后一条指令返回给调用者。
现在让我们考虑一个稍微复杂的方法:
![[Pasted image 20211020232843.png]]
他的字节码如下所示：
![[Pasted image 20211020232904.png]]
![[Pasted image 20211020232914.png]]
第一条指令将初始化为 f 的局部变量 1 压入操作数堆栈。 IFLT 指令将该值从堆栈中弹出，并与 0 进行比较。如果小于 (LT) 0，则跳转到 label 标签指定的指令，否则不执行任何操作，继续执行下一条指令。接下来的三个指令与 setF 方法中的指令相同。 GOTO 指令无条件跳转到 end 标签指定的指令，即RETURN 指令。label 和 end 标签之间的指令创建并抛出异常：NEW 指令创建一个异常对象并将其压入操作数堆栈。 DUP 指令在堆栈上复制此值。 INVOKESPECIAL 指令弹出这两个副本之一并在其上调用异常构造函数。最后，ATHROW 指令弹出剩余的副本并将其作为异常抛出（因此不会继续执行下一条指令）。
### 3.1.4 异常处理
try和catch标签之间的代码对应try块，catch标签后面的代码对应catch块。 TRYCATCHBLOCK 行指定了一个异常处理程序，它涵盖了 try 和 catch 标签之间的范围，处理程序从 catch 标签开始，并且用于类是 InterruptedException 的子类的异常。这意味着如果在 try 和 catch 之间的任何地方抛出此类异常，堆栈将被清除，异常将被推送到这个空堆栈上，并在 catch 处继续执行。
### 3.1.5 帧
用 Java 6 或更高版本编译的类除了字节码指令外，还包含一组堆栈映射帧，用于加速 Java 虚拟机内的类验证过程。 堆栈映射帧给出了方法在执行期间某个时刻的执行帧的状态。 更准确地说，它给出了在执行某些特定字节码指令之前包含在每个局部变量槽和每个操作数堆栈槽中的值的类型。
例如，如果我们考虑上一节的 getF 方法，我们可以定义三个堆栈映射帧，分别在 ALOAD 之前、GETFIELD 之前和 IRETURN 之前给出执行帧的状态。 这三个堆栈映射帧对应于图 3.2 所示的三种情况，可以描述如下，其中第一个方括号之间的类型对应于局部变量，其余的对应于操作数堆栈：
![[Pasted image 20211026234644.png]]
同样的，checkAndSetF：
![[Pasted image 20211026234750.png]]

除了 Uninitialized(label) 类型之外，这与之前的方法类似。这是一种仅在堆栈映射帧中使用的特殊类型，它指定一个已分配内存但尚未调用其构造函数的对象。参数指定创建此对象的指令。可以对该类型的值调用的唯一可能方法是构造函数。当它被调用时，框架中所有出现的这种类型都被替换为真实类型，这里是 IllegalArgumentException。堆栈映射帧可以使用其他三种特殊类型：UNINITIALIZED_THIS 是构造函数中局部变量 0 的初始类型，TOP 对应未定义值，NULL 对应空值。
如上所述，从 Java 6 开始，已编译的类除了字节码之外，还包含一组堆栈映射帧。为了节省空间，编译的方法每条指令不包含一个帧：实际上它只包含对应于跳转目标或异常处理程序的指令的帧，或者跟随无条件跳转指令的帧。事实上，可以从这些帧中轻松快速地推断出其他帧。
在 checkAndSetF 方法的情况下，这意味着只存储两帧：一帧用于 NEW 指令，因为它是 IFLT 指令的目标，但也因为它遵循无条件跳转 GOTO 指令，另一帧用于RETURN 指令，因为它是GOTO 指令的目标，也因为它跟在“无条件跳转”ATHROW 指令之后。
为了节省更多的空间，每帧都被压缩，只存储它与前一帧的差异，并且根本不存储初始帧，因为它可以很容易地从方法参数类型中推导出来。在 checkAndSetF 方法的情况下，必须存储的两个帧相等并且等于初始帧，因此它们被存储为 F_SAME 助记符指定的单字节值。这些帧可以在其关联的字节码指令之前表示。这给出了 checkAndSetF 方法的最终字节码：
![[Pasted image 20211026235654.png]]

## 3.2 接口和组件
### 3.2.1 介绍
用于生成和转换已编译方法的 ASM API 基于 MethodVisitor 抽象类（见图 3.4），该类由 ClassVisitor 的 visitMethod 方法返回。除了一些与注解和调试信息相关的方法外，这些方法将在下一章解释，这个类根据这些指令的参数数量和类型为每个字节码指令类别定义了一个方法（这些类别与在第 3.1.2 节中介绍）。这些方法必须按以下顺序调用（在 MethodVisitor 接口的 Javadoc 中指定了一些额外的约束）：
![[Pasted image 20211026230824.png]]
这意味着对于非抽象方法，必须首先访问注释和属性（如果有），然后是方法的字节码。对于这些方法，必须按顺序访问代码，恰好在一次调用visitCode 和恰好一次调用visitMaxs 之间。
![[Pasted image 20211026231042.png]]
因此，visitCode 和visitMaxs 方法可用于检测事件序列中方法字节码的开始和结束。与类一样，visitEnd 方法必须最后调用，用于检测事件序列中方法的结束。
可以组合 ClassVisitor 和 MethodVisitor 类以生成完整的类：
![[Pasted image 20211026231354.png]]
请注意，没有必要完成一种方法才能开始访问另一种方法。事实上 MethodVisitor 实例是完全独立的，可以以任何顺序使用（只要 cv.visitEnd() 没有被调用）：
![[Pasted image 20211026231431.png]]
ASM 提供了三个基于 MethodVisitor API 的核心组件来生成和转换方法：
• ClassReader 类解析已编译方法的内容，并在作为参数传递给其接受方法的 ClassVisitor 返回的 MethodVisitor 对象上调用相应的方法。
• ClassWriter 的visitMethod 方法返回MethodVisitor 接口的一个实现，该接口直接以二进制形式构建已编译的方法。
• MethodVisitor 类将它接收到的所有方法调用委托给另一个 MethodVisitor 实例。它可以看作是一个事件过滤器。


正如我们在 3.1.5 节中看到的，计算一个方法的堆栈映射帧并不是很容易：你必须计算所有的帧，找到对应跳转目标或跟随无条件跳转的帧，最后压缩这些剩余的帧帧。同样，计算方法的局部变量和操作数堆栈部分的大小更容易，但仍然不是很容易。
希望 ASM 可以为您计算这个。创建 ClassWriter 时，您可以指定必须自动计算的内容：
• 使用 new ClassWriter(0) 不会自动计算任何内容。您必须自己计算帧和局部变量以及操作数堆栈大小。
• 使用 new ClassWriter(ClassWriter.COMPUTE_MAXS) 为您计算局部变量和操作数堆栈部分的大小。您仍然必须调用visitMaxs，但您可以使用任何参数：它们将被忽略并重新计算。使用此选项，您仍然需要自己计算帧。
• 使用 new ClassWriter(ClassWriter.COMPUTE_FRAMES) 自动计算所有内容。您不必调用visitFrame，但仍必须调用visitMaxs（参数将被忽略并重新计算）。

使用这些选项很方便，但这是有代价的：COMPUTE_MAXS 选项会使 ClassWriter 慢 10%，而使用 COMPUTE_FRAMES 选项会使它慢两倍。这必须与自己计算所需的时间进行比较：在特定情况下，与 ASM 中使用的算法相比，通常有更简单、更快的算法来计算它，后者必须处理所有情况。

请注意，如果您选择自己计算帧，则可以让 ClassWriter 类为您执行压缩步骤。为此，您只需使用visitFrame(F_NEW, nLocals, locals,nStack, stack) 访问未压缩的帧，其中nLocals 和nStack 是局部变量的数量和操作数堆栈大小，局部变量和堆栈是包含相应的数组。类型（有关更多详细信息，请参阅 Javadoc）。

另请注意，为了自动计算帧，有时需要计算两个给定类的公共超类。默认情况下，ClassWriter 类在 getCommonSuperClass 方法中通过将两个类加载到 JVM 中并使用反射 API 来计算它。如果您生成多个相互引用的类，这可能是一个问题，因为引用的类可能尚不存在。在这种情况下，您可以覆盖 getCommonSuperClass 方法来解决此问题。
### 3.2.2 生成方法
3.1.3中的getF方法可以表示成如下，mv表示MethodVisitor：
![[Pasted image 20211026231938.png]]
第一个调用标志着字节码生成的开始。 随后是三个调用，生成此方法的三个指令（如您所见，字节码和 ASM API 之间的映射非常简单）。 必须在访问完所有指令后调用visitMaxs。 它用于为该方法的执行帧定义局部变量和操作数堆栈部分的大小。 正如我们在 3.1.3 节中看到的，每个部分的大小都是1。 最后一个调用用于结束方法的生成。
![[Pasted image 20211020224621.png]]
![[Pasted image 20211020224648.png]]
![[Pasted image 20211020231743.png]]
setF 方法和构造函数的字节码可以用类似的方式生成。 一个更有趣的例子是 checkAndSetF 方法：
![[Pasted image 20211020232843.png]]
![[Pasted image 20211020232904.png]]
![[Pasted image 20211020232914.png]]

![[Pasted image 20211026233304.png]]
![[Pasted image 20211026233315.png]]
在visitCode 和visitEnd 调用之间，您可以看到完全映射到第3.1.5 节末尾显示的字节码的方法调用：每个指令、标签或帧调用一次（唯一的例外是标签的声明和构造以及 结束标签对象）。

一个 Label 对象指定此标签的 visitLabel 调用之后的指令。 例如，end 指定 RETURN 指令，而不是紧接其后访问的帧，因为这不是一条指令。 有多个标签指定同一条指令是完全合法的，但一个标签必须只指定一条指令。 换句话说，可以使用不同的标签连续调用visitLabel，但指令中使用的标签必须使用visitLabel 只访问一次。 最后一个限制是标签不能共享：每个方法必须有自己的标签。
### 3.2.3 转换方法
您现在应该已经猜到方法可以像类一样转换，即通过使用 method adapter 转发它接收到的方法调用并进行一些修改：更改参数可用于更改单个指令，而不是转发接收到的调用删除指令，并在接收到的调用之间插入调用会添加新指令。 MethodVisitor 类提供了这种方法适配器的基本实现，它只是转发它接收到的所有方法调用。
为了理解如何使用方法适配器，让我们考虑一个非常简单的适配器，它删除了方法内部的 NOP 指令（它们可以毫无问题地删除，因为它们什么都不做）：
![[Pasted image 20211027211121.png]]
![[Pasted image 20211027211132.png]]
这个 adapter 可以被用在一个 class adapter 中：
![[Pasted image 20211027211412.png]]
换句话说，类适配器只是构建了一个方法适配器，封装了链中下一个类访问者返回的方法访问者，并返回这个适配器。其效果是构建了一个类似于类适配器链的方法适配器链（见图 3.5）。
![[Pasted image 20211027212445.png]]
但是请注意，这不是强制性的：完全有可能构建一个与类适配器链不相似的方法适配器链。每个方法甚至可以有不同的方法适配器链。例如，类适配器可以选择仅在方法中而不是在构造函数中删除 NOP。这可以按如下方式完成：
![[Pasted image 20211027211613.png]]
在这种情况下，构造函数的适配器链较短。相反，构造函数的适配器链可以更长，在visitMethod 中创建多个链接在一起的方法适配器。方法适配器链甚至可以具有与类适配器链不同的拓扑结构。例如，类适配器链可以是线性的，而方法适配器链有分支：
![[Pasted image 20211027212301.png]]
现在我们已经了解了如何将方法适配器和类适配器组合使用，让我们看看如何实现比 RemoveNopAdapter 更有趣的适配器。
###  3.2.4 无状态转换
假设我们要测量在程序的每个类中花费的时间。 我们需要在每个类中添加一个静态定时器字段，并且我们需要将这个类的每个方法的执行时间添加到这个定时器字段中。 换句话说，我们想要转换一个类，比如 C：
![[Pasted image 20211027213225.png]]
![[Pasted image 20211027213240.png]]
为了了解如何在 ASM 中实现这一点，我们可以编译这两个类并比较这两个版本上 TraceClassVisitor 的输出（使用默认 Textifier 后端，或使用 ASMifier 后端）。 使用默认后端，我们得到以下差异（粗体）：
![[Pasted image 20211027213720.png]]
我们看到必须在方法的开头添加四条指令，在返回指令之前添加其他四条指令。 我们还需要更新最大操作数堆栈大小。 方法代码的开头是用visitCode方法访问的。 因此，我们可以通过在我们的方法适配器中覆盖此方法来添加前四个指令：
![[Pasted image 20211027215154.png]]
其中 owner 必须设置为正在转换的类的名称。 我们现在必须在任何 RETURN 之前添加其他四个指令，但也要在任何 xRETURN 之前或 ATHROW 之前添加，它们都是终止方法执行的指令。 这些指令没有任何参数，因此在visitInsn 方法中访问。 然后我们可以覆盖这个方法以添加我们的指令：
![[Pasted image 20211027215359.png]]
最后，我们必须更新最大操作数堆栈大小。我们添加的指令压入两个 long 值，因此在操作数堆栈上需要四个插槽。在方法的开头，操作数栈最初是空的，所以我们知道开头添加的 4 条指令需要大小为 4 的栈。我们也知道我们插入的代码保持栈状态不变（因为当push时会pop出相同数量的值）。因此，如果原始代码需要大小为 s 的堆栈，则转换方法所需的最大堆栈大小为 max(4,s)。不幸的是，我们还在返回指令之前添加了四条指令，这里我们不知道这些指令之前的操作数堆栈的大小。我们只知道它小于或等于s。因此，我们可以说在返回指令之前添加的代码可能需要一个最大 s+4 的操作数堆栈。这种最坏的情况在实践中很少发生：对于常见的编译器，RETURN 之前的操作数堆栈仅包含返回值，即它的大小最多为 0、1 或 2。但是如果我们想处理所有可能的情况，我们需要使用最坏的情况。然后我们必须重写visitMaxs方法，如下所示：
![[Pasted image 20211027215848.png]]
当然，可以不考虑最大堆栈大小并依赖 COMPUTE_MAXS 选项，此外，该选项将计算最佳值而不是最坏情况值。 但是对于这种简单的转换，手动更新 maxStack 并不需要花费太多精力。
现在一个有趣的问题是：堆栈映射帧呢？ 原来的代码不包含任何框架，也没有转换的框架，但这是由于我们作为示例使用的特定代码吗？ 在某些情况下必须更新框架吗？ 答案是否定的，因为 1) 插入的代码保持操作数堆栈不变，2) 插入的代码不包含跳转指令，以及 3) 原始代码的跳转指令——或者更正式地说，控制流图——没有被修改 . 这意味着原始帧不会改变，并且由于不需要为插入的代码存储新帧，因此压缩的原始帧也不会改变。

我们现在可以将所有元素放在关联的 ClassVisitor 和 MethodVisitor 子类中：
![[Pasted image 20211027220107.png]]
![[Pasted image 20211027220118.png]]
类适配器用于实例化方法适配器（构造函数除外），还用于添加计时器字段并将正在转换的类的名称存储在可从方法适配器访问的字段中。
### 3.2.5 有状态转换
上一节中看到的转换是局部的，不依赖于在当前指令之前已经访问过的指令：开头添加的代码始终相同并且始终添加，对于在每个 RETURN 指令之前插入的代码也是如此.这种转换称为无状态转换。它们易于实现，但只有最简单的转换才能验证此属性。

更复杂的转换需要记住在当前指令之前访问过的指令的一些状态。例如，考虑删除所有出现的 ICONST_0 IADD 序列的转换，其空效果是加 0。很明显，当访问 IADD 指令时，只有当最后访问的指令是 ICONST_0 时才必须删除它。

这需要在方法适配器中存储状态。因此，此类转换称为有状态转换。

让我们看看这个例子的更多细节。当访问 ICONST_0 时，仅当下一条指令是 IADD 时才必须将其删除。问题是下一条指令还不知道。解决方案是将此决定推迟到下一条指令：如果是 IADD，则删除两条指令，否则发出 ICONST_0 和当前指令。

为了实现移除或替换某些指令序列的转换，可以方便地引入一个 MethodVisitor 子类，它的 visitXxx Insn 方法调用一个共同的 visitInsn() 方法：

![[Pasted image 20211027221605.png]]
它的实现如下：
![[Pasted image 20211027221733.png]]
![[Pasted image 20211027221750.png]]
### Labels 和 frames
正如我们在前几节中看到的，label 和 frame 在它们相关的指令之前被访问。换句话说，它们与指令同时被访问，尽管它们本身不是指令。这对检测指令序列的转换有影响，但这种影响实际上是一个优势。事实上，如果我们删除的指令之一是跳转指令的目标，会发生什么？如果某条指令可能跳转到 ICONST_0，这意味着有一个标签指定了这条指令。去掉这两条指令（ICONST_0 和 IADD）后，这个标签会指定跟在去掉的 IADD 后面的指令，这就是我们想要的。但是如果某条指令可能跳转到 IADD，我们不能移除指令序列（我们不能确定在这次跳转之前一个 0 被压入堆栈）。希望在这种情况下，ICONST_0 和 IADD 之间必须有一个标签，可以很容易地检测到。
堆栈映射帧的推理是相同的：如果在两条指令之间访问了堆栈映射帧，我们不能删除它们。这两种情况都可以通过将标签和帧视为模式匹配算法中的指令来处理。这可以在 PatternMethodAdapter 中完成（注意，visitMaxs 也调用了常见的 visitInsn 方法；这用于处理方法的结尾是必须检测的序列的前缀的情况）：
![[Pasted image 20211027225423.png]]
（ps：意思是 end、ICONST_0 、IADD 这种情况就可以删，ICONST_0 、end、IADD 这种情况就不能删）。
## 3.3 工具
org.objectweb.asm.commons 包包含一些预定义的方法适配器，可用于定义您自己的适配器。 本节介绍了其中的三个，并展示了如何将它们与 3.2.4 节的 AddTimerAdapter 示例一起使用。 它还展示了如何使用前一章中看到的工具来简化方法生成或转换。
### 3.3.1 基础工具
**Type**

许多字节码指令，例如 xLOAD、xADD 或 xRETURN，取决于它们所应用的类型。 Type 类提供了一个 getOpcode 方法，该方法可用于为这些指令获取与给定类型对应的操作码。 此方法将 int 类型的操作码作为参数，并返回调用它的类型的操作码。 例如，如果 t 等于 Type.FLOAT_TYPE，则 t.getOpcode(IMUL) 返回 FMUL。

**TraceClassVisitor**

之前介绍过生成打印类的字节码的方法：
![[Pasted image 20211028213535.png]]
如果您想在链中的某个点跟踪单个方法的内容，而不是跟踪其类的所有内容，您可以使用 TraceMethodVisitor 而不是 TraceClassVisitor（在这种情况下，您必须明确指定后端； 这里我们使用一个 Textifier）：
![[Pasted image 20211028213711.png]]
![[Pasted image 20211028213723.png]]

**CheckClassAdapter**

此类已在前一章中介绍过，它检查 ClassVisitor 方法是否以适当的顺序被调用，并且具有有效的参数，并且它对 MethodVisitor 方法执行相同的操作。 因此，它可用于检查 MethodVisitor API 在转换链中的任何点是否正确使用。 与 TraceMethodVisitor 一样，您可以使用 CheckMethodAdapter 类来检查单个方法，而不是检查其所有类：
![[Pasted image 20211028214121.png]]
此代码检查 MyMethodAdapter 是否正确使用 MethodVisitor API。 但是请注意，此适配器不会检查字节码是否正确：例如，它不会检测到 ISTORE 1 ALOAD 1 无效。 事实上，如果您使用 CheckMethodAdapter 的其他构造函数（参见 Javadoc），并且如果您在 visitMaxs 中提供有效的 maxStack 和 maxLocals 参数，则可以检测到此类错误。

**ASMifier**
这个在前一章中已经介绍过的类也适用于方法的内容。 它可以用来知道如何用ASM生成一些编译代码：只需用Java编写相应的源代码，用javac编译它，并使用ASMifier访问这个类。 您将获得 ASM 代码以生成与您的源代码对应的字节码。

### 3.3.2  AnalyzerAdapter
此方法适配器根据 visitFrame 中访问的帧，在每条指令之前计算堆栈映射帧的大小。确实，如3.1.5节所述，visitFrame只在方法中的某些特定指令之前调用，以节省空间，并且因为“可以从这些帧中轻松快速地推断出其他帧”。这就是这个适配器的作用。当然，它仅适用于包含预先计算的堆栈映射帧的类，即使用 Java 6 或更高版本编译（或之前使用 COMPUTE_FRAMES 选项通过 ASM 适配器升级到 Java 6）。
在我们的 AddTimerAdapter 示例中，此适配器可用于在 RETURN 指令之前获取操作数堆栈的大小，从而允许在 visitMaxs 中为 maxStack 计算最佳转换值（实际上，这种方法在实践中并不推荐，因为它比使用 COMPUTE_MAXS 效率低得多）：
![[Pasted image 20211028215935.png]]
![[Pasted image 20211028215946.png]]
等价与：
![[Pasted image 20211028220308.png]]

### 3.3.3  LocalVariablesSorter
此方法适配器按照它们在此方法中出现的顺序对方法中使用的局部变量重新编号。 例如，在具有两个参数的方法中，读取或写入索引大于或等于 3 的第一个局部变量被分配 索引 3，第二个被分配索引 4，依此类推。 此适配器可用于在方法中插入新的局部变量。 如果没有这个适配器，就需要在所有现有的局部变量之后添加新的局部变量，但不幸的是，直到方法结束时，visitMaxs 中才知道它们的数量。
为了展示如何使用这个适配器，假设我们想使用一个局部变量来实现 AddTimerAdapter：
![[Pasted image 20211028220733.png]]
这可以通过扩展 LocalVariablesSorter 并使用此类中定义的 newLocal 方法轻松完成：
![[Pasted image 20211028220910.png]]
![[Pasted image 20211028220925.png]]
之前的：
![[Pasted image 20211028221354.png]]

当局部变量重新编号时，与该方法关联的原始帧将变得无效，并且在插入新的局部变量时更是如此。LocalVariablesSorter 会自动处理这些，从而避免从头开始重新计算这些帧。
正如你在上面看到的，使用局部变量并不能解决我们在这个类的原始版本中遇到的问题，即 maxStack 的最坏情况值。如果你想使用 AnalyzerAdapter 来解决这个问题，除了 LocalVariablesSorter 之外，你必须通过委托而不是通过继承来使用这些适配器（因为多继承是不可能的）：
![[Pasted image 20211028222557.png]]
![[Pasted image 20211028222608.png]]

为了使用这个适配器，你必须将一个 LocalVariablesSorter 链接到一个 AnalyzerAdapter，它本身链接到你的适配器：
![[Pasted image 20211028222633.png]]

### 3.3.4
此方法适配器是一个抽象类，可用于在方法的开头和任何 RETURN 或 ATHROW 指令之前插入代码。 它的主要优点是它也适用于构造函数，构造函数的代码不能插入在构造函数的开头，而是在调用super构造函数之后。 实际上这个适配器的大部分代码都是专门用于检测这个super构造函数调用的。
如果仔细查看 3.2.4 节中的 AddTimerAdapter 类，您会发现 AddTimerMethodAdapter 没有用于构造函数，因为这个问题。 通过从 AdviceAdapter 继承，这个方法适配器也可以改进为在构造函数上工作（注意 AdviceAdapter 继承自 LocalVariablesSorter，所以我们也可以轻松地使用局部变量）：
![[Pasted image 20211028223245.png]]
![[Pasted image 20211028223307.png]]