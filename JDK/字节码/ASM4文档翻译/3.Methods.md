# 3.Methods
本章解释了如何使用核心 ASM API 生成和转换已编译的方法。
## 3.1.结构
在已编译的类中，方法代码存储为字节码指令序列。为了生成和转换类，了解这些指令并理解它们是如何工作的至关重要。
### 3.1.1.执行模型
在介绍字节码指令之前，有必要介绍一下 Java 虚拟机执行模型。如您所知，Java 代码是在线程内执行的。每个线程都有自己的执行栈，由帧组成。每个帧代表一个方法调用：每次调用一个方法时，都会在当前线程的执行堆栈上推送一个新帧。当方法返回时，无论是正常情况还是由于异常，都会从执行堆栈中弹出此帧，并在调用方法（其帧现在位于堆栈顶部）中继续执行。

每个帧包含两部分：**局部变量**部分和**操作数堆栈**部分。局部变量部分包含可以按随机顺序通过索引访问的变量。操作数堆栈部分，顾名思义，是字节码指令用作操作数的值堆栈。这意味着只能以后进先出的顺序访问此堆栈中的值。不要混淆操作数堆栈和线程的执行堆栈：执行堆栈中的每个帧都包含自己的操作数堆栈。

局部变量和操作数堆栈部分的大小取决于方法的代码。它在编译时计算并与字节码指令一起存储在编译类中。因此，对应于给定方法调用的所有帧具有相同的大小，但对应于不同方法的帧的局部变量和操作数堆栈部分可以具有不同的大小。
![[Pasted image 20211020213731.png]]
图 3.1 显示了一个包含 3 个帧的示例执行堆栈。第一帧包含 3 个局部变量，其操作数堆栈的最大大小为 4，并且包含两个值。第二帧包含 2 个局部变量和其操作数堆栈中的两个值。最后，在执行堆栈顶部的第三帧包含 4 个局部变量和两个操作数。

当它被创建时，一个帧用一个空堆栈初始化，它的局部变量用目标对象 this（对于非静态方法）和方法的参数初始化。例如，调用 a.equals(b) 方法会创建一个带有空堆栈的帧，并且前两个局部变量初始化为 a 和 b（其他局部变量未初始化）。

局部变量和操作数堆栈部分中的每个插槽都可以保存任何 Java 值，除了 long 和 double 值。这些值需要两个插槽。这使局部变量的管理变得复杂：例如，第 i 个方法参数不一定存储在局部变量 i 中。例如，调用 Math.max(1L, 2L) 创建一个帧，在前两个局部变量槽中具有 1L 值，在第三和第四槽中具有值 2L。

### 3.1.2.字节码指令
字节码指令由标识该指令的**操作码**和固定数量的**参数**组成：

- 操作码 是一个无符号字节值——因此是字节码名称——并由助记符标识。例如操作码值 0 是由助记符 NOP 设计的，对应于什么都不做的指令。
- 参数是定义精确指令行为的静态值。它们在操作码之后给出。例如，操作码值为 167 的 GOTO 标签指令采用标签作为参数，该标签指定要执行的下一条指令。指令参数不能与指令操作数混淆：参数值是静态已知的并存储在编译代码中，而操作数值来自操作数堆栈并且仅在运行时已知。

字节码指令可以分为两类：一小组指令用于将值从局部变量传输到操作数堆栈，或者相反；其他指令仅作用于操作数堆栈：它们从堆栈中弹出一些值，根据这些值计算结果，并将其压回到堆栈上。

ILOAD、LLOAD、FLOAD、DLOAD 和 ALOAD 指令读取局部变量并将其值压入操作数堆栈。它们将必须读取的局部变量的索引 i 作为参数。 ILOAD 用于加载 boolean、byte、char、short 或 int 局部变量。 LLOAD、FLOAD 和 DLOAD 分别用于加载 long、float 或 double 值（LLOAD 和 DLOAD 实际上加载了两个插槽， i 和 i + 1）。最后 ALOAD 用于加载任何非原始值，即对象和数组引用。 

ISTORE、LSTORE、FSTORE、DSTORE 和 ASTORE 指令对称地从操作数堆栈中弹出一个值并将其存储在由其索引 i 指定的局部变量中。

实际上，将值存储在局部变量中然后用不同的类型加载它是非法的。例如，ISTORE 1 ALOAD 1 序列是非法的——它允许在局部变量 1 中存储任意内存地址，并将该地址转换为对象引用！然而，在局部变量中存储类型与存储在该局部变量中的当前值类型不同的值是完全合法的。这意味着局部变量的类型，即存储在该局部变量中的值的类型，可以在方法执行期间改变。

如上所述，所有其他字节码指令仅适用于操作数堆栈。它们可以分为以下几类：
- 栈指令：这些指令用于操作堆栈上的值：POP-弹出堆栈顶部的值，DUP-压入堆栈顶部值的副本，SWAP-弹出两个值并以相反的顺序压入它们，等等。
- 常量指令：这些指令将常量值压入操作数堆栈：ACONST_NULL 压入空值，ICONST_0 压入 int 值 0，FCONST_0 压入 0f，DCONST_0 压入 0d，BIPUSH b 压入字节值 b，SIPUSH s 压入 shot 值 s，LDC cst 压入 任意 int、float、long、double、String 或 class1、常量 cst 等。
- 算术和逻辑指令：这些指令从操作数堆栈中弹出数值，并将组合后的结果压入堆栈。xADD、xSUB、xMUL、xDIV 和 xREM 对应于 +、-、\*、/ 和 % 操作，其中 x 是 I、L、F 或 D。类似地，还有其他指令对应于 <‌<、>‌>， >‌>‌>、|、& 和 ^，用于 int 和 long 值。
- 转换指令：这些指令从堆栈中弹出一个值，将其转换为另一种类型，并将结果推回。 它们对应于 Java 中的强制转换表达式。 I2F、F2D、L2D 等将数值从一种数值类型转换为另一种数值类型。 CHECKCAST t 将引用值转换为类型 t。
- 对象指令：这些指令用于创建对象、锁定它们、检查它们的类型等。例如，NEW type 指令将类型为 type 的新对象压入堆栈（其中 type 是内部名称）。
- 字段指令：这些指令读取或写入字段的值。 GETFIELD owner name desc 弹出一个对象引用，并压入其 name 字段的值。 PUTFIELD owner name desc 弹出一个值和一个对象引用，并将该值存储在其名称字段中。 在这两种情况下，对象都必须是 owner 类型，并且它的字段必须是 desc 类型。 GETSTATIC 和 PUTSTATIC 是类似的指令，但用于静态字段。
- 方法指令：这些指令调用方法或构造函数。 它们弹出与方法参数一样多的值，以及一个代表目标对象的值，并压入方法调用的结果。 INVOKEVIRTUAL owner name desc 调用类owner 中定义的name 方法，其方法描述符为desc。 INVOKESTATIC 用于静态方法，INVOKESPECIAL 用于私有方法和构造函数，INVOKEINTERFACE 用于接口中定义的方法。 最后，对于 Java 7 中的类，INVOKEDYNAMIC 用于新的动态方法调用机制。
- 数组指令：这些指令用于读取和写入数组中的值。 xALOAD 指令弹出一个索引和一个数组，并压入数组在索引处的值。 xASTORE 指令弹出一个值、一个索引和一个数组，并将这个值存储在数组中的那个索引处。 这里 x 可以是 I、L、F、D 或 A，也可以是 B、C 或 S。
- 跳转指令：如果某些条件为真或无条件为真，这些指令将跳转到任意指令。 它们用于编译 if、for、do、while、break 和 continue 指令。 例如，IFEQ label 从堆栈中弹出一个 int 值，如果该值为 0，则跳转到 label 指令（否则继续正常执行到下一条指令）。 存在许多其他跳转指令，例如 IFNE 或 IFGE。 最后 TABLESWITCH 和 LOOKUPSWITCH 对应的是 switch 指令。
- 返回指令：最后，xRETURN 和 RETURN 指令用于终止方法的执行并将其结果返回给调用者。 RETURN 用于返回 void 的方法，而 xRETURN 用于其他方法。
### 3.1.3 实例
![[Pasted image 20211020224621.png]]
看一下getter方法的字节码：
![[Pasted image 20211020224648.png]]
在方法调用时，帧被创建，与此同时 this 也被初始化在了局部变量中。所以第一步是读取局部变量0到操作数栈中；第二条指令从堆栈中弹出这个值，即 this，并压入这个对象的 f 字段，即 this.f。 最后一条指令从堆栈中弹出这个值，并将其返回给调用者。 该方法的执行帧的连续状态如图 3.2 所示。
![[Pasted image 20211020231743.png]]
在看一下setter方法的字节码：
![[Pasted image 20211020232018.png]]
第一条指令像以前一样将 this 压入操作数堆栈。 第二条指令压入局部变量 1，该变量在该方法调用时创建帧期间，使用 f 参数值进行初始化。 第三条指令弹出这两个值并将 int 值存储在引用对象的 f 字段中，即在 this.f 中。 最后一条指令，在源代码中是隐藏的，但在编译代码中是强制性的，它终止当前的执行帧并返回给调用者。 该方法的执行帧的连续状态如图 3.3 所示。
![[Pasted image 20211020232343.png]]
Bean 类还有一个默认的公共构造函数，它由编译器生成，因为程序员没有定义显式构造函数。 这个默认的公共构造函数生成为 Bean() { super(); }. 此构造函数的字节码如下：
![[Pasted image 20211020232516.png]]
![[Pasted image 20211020232530.png]]
第一条指令将其压入操作数堆栈。 第二条指令从堆栈中弹出这个值，并调用 Object 类中定义的 init 方法。 这对应于 super() 调用，即对超类 Object 的构造函数的调用。 您可以在此处看到构造函数在编译类和源类中的命名不同：在编译类中，它们始终命名为 init，而在源类中，它们具有定义它们的类的名称。 最后最后一条指令返回给调用者。
现在让我们考虑一个稍微复杂的方法:
![[Pasted image 20211020232843.png]]
他的字节码如下所示：
![[Pasted image 20211020232904.png]]
![[Pasted image 20211020232914.png]]
第一条指令将初始化为 f 的局部变量 1 压入操作数堆栈。 IFLT 指令将该值从堆栈中弹出，并与 0 进行比较。如果小于 (LT) 0，则跳转到 label 标签指定的指令，否则不执行任何操作，继续执行下一条指令。接下来的三个指令与 setF 方法中的指令相同。 GOTO 指令无条件跳转到 end 标签指定的指令，即RETURN 指令。label 和 end 标签之间的指令创建并抛出异常：NEW 指令创建一个异常对象并将其压入操作数堆栈。 DUP 指令在堆栈上复制此值。 INVOKESPECIAL 指令弹出这两个副本之一并在其上调用异常构造函数。最后，ATHROW 指令弹出剩余的副本并将其作为异常抛出（因此不会继续执行下一条指令）。
### 3.1.4 异常处理
try和catch标签之间的代码对应try块，catch标签后面的代码对应catch块。 TRYCATCHBLOCK 行指定了一个异常处理程序，它涵盖了 try 和 catch 标签之间的范围，处理程序从 catch 标签开始，并且用于类是 InterruptedException 的子类的异常。这意味着如果在 try 和 catch 之间的任何地方抛出此类异常，堆栈将被清除，异常将被推送到这个空堆栈上，并在 catch 处继续执行。
### 3.1.5 帧
用 Java 6 或更高版本编译的类除了字节码指令外，还包含一组堆栈映射帧，用于加速 Java 虚拟机内的类验证过程。 堆栈映射帧给出了方法在执行期间某个时刻的执行帧的状态。 更准确地说，它给出了在执行某些特定字节码指令之前包含在每个局部变量槽和每个操作数堆栈槽中的值的类型。
例如，如果我们考虑上一节的 getF 方法，我们可以定义三个堆栈映射帧，分别在 ALOAD 之前、GETFIELD 之前和 IRETURN 之前给出执行帧的状态。 这三个堆栈映射帧对应于图 3.2 所示的三种情况，可以描述如下，其中第一个方括号之间的类型对应于局部变量，其余的对应于操作数堆栈：
![[Pasted image 20211026234644.png]]
同样的，checkAndSetF：
![[Pasted image 20211026234750.png]]

除了 Uninitialized(label) 类型之外，这与之前的方法类似。这是一种仅在堆栈映射帧中使用的特殊类型，它指定一个已分配内存但尚未调用其构造函数的对象。参数指定创建此对象的指令。可以对该类型的值调用的唯一可能方法是构造函数。当它被调用时，框架中所有出现的这种类型都被替换为真实类型，这里是 IllegalArgumentException。堆栈映射帧可以使用其他三种特殊类型：UNINITIALIZED_THIS 是构造函数中局部变量 0 的初始类型，TOP 对应未定义值，NULL 对应空值。
如上所述，从 Java 6 开始，已编译的类除了字节码之外，还包含一组堆栈映射帧。为了节省空间，编译的方法每条指令不包含一个帧：实际上它只包含对应于跳转目标或异常处理程序的指令的帧，或者跟随无条件跳转指令的帧。事实上，可以从这些帧中轻松快速地推断出其他帧。
在 checkAndSetF 方法的情况下，这意味着只存储两帧：一帧用于 NEW 指令，因为它是 IFLT 指令的目标，但也因为它遵循无条件跳转 GOTO 指令，另一帧用于RETURN 指令，因为它是GOTO 指令的目标，也因为它跟在“无条件跳转”ATHROW 指令之后。
为了节省更多的空间，每帧都被压缩，只存储它与前一帧的差异，并且根本不存储初始帧，因为它可以很容易地从方法参数类型中推导出来。在 checkAndSetF 方法的情况下，必须存储的两个帧相等并且等于初始帧，因此它们被存储为 F_SAME 助记符指定的单字节值。这些帧可以在其关联的字节码指令之前表示。这给出了 checkAndSetF 方法的最终字节码：
![[Pasted image 20211026235654.png]]

## 3.2 接口和组件
### 3.2.1 介绍
用于生成和转换已编译方法的 ASM API 基于 MethodVisitor 抽象类（见图 3.4），该类由 ClassVisitor 的 visitMethod 方法返回。除了一些与注解和调试信息相关的方法外，这些方法将在下一章解释，这个类根据这些指令的参数数量和类型为每个字节码指令类别定义了一个方法（这些类别与在第 3.1.2 节中介绍）。这些方法必须按以下顺序调用（在 MethodVisitor 接口的 Javadoc 中指定了一些额外的约束）：
![[Pasted image 20211026230824.png]]
这意味着对于非抽象方法，必须首先访问注释和属性（如果有），然后是方法的字节码。对于这些方法，必须按顺序访问代码，恰好在一次调用visitCode 和恰好一次调用visitMaxs 之间。
![[Pasted image 20211026231042.png]]
因此，visitCode 和visitMaxs 方法可用于检测事件序列中方法字节码的开始和结束。与类一样，visitEnd 方法必须最后调用，用于检测事件序列中方法的结束。
可以组合 ClassVisitor 和 MethodVisitor 类以生成完整的类：
![[Pasted image 20211026231354.png]]
请注意，没有必要完成一种方法才能开始访问另一种方法。事实上 MethodVisitor 实例是完全独立的，可以以任何顺序使用（只要 cv.visitEnd() 没有被调用）：
![[Pasted image 20211026231431.png]]
ASM 提供了三个基于 MethodVisitor API 的核心组件来生成和转换方法：
• ClassReader 类解析已编译方法的内容，并在作为参数传递给其接受方法的 ClassVisitor 返回的 MethodVisitor 对象上调用相应的方法。
• ClassWriter 的visitMethod 方法返回MethodVisitor 接口的一个实现，该接口直接以二进制形式构建已编译的方法。
• MethodVisitor 类将它接收到的所有方法调用委托给另一个 MethodVisitor 实例。它可以看作是一个事件过滤器。


正如我们在 3.1.5 节中看到的，计算一个方法的堆栈映射帧并不是很容易：你必须计算所有的帧，找到对应跳转目标或跟随无条件跳转的帧，最后压缩这些剩余的帧帧。同样，计算方法的局部变量和操作数堆栈部分的大小更容易，但仍然不是很容易。
希望 ASM 可以为您计算这个。创建 ClassWriter 时，您可以指定必须自动计算的内容：
• 使用 new ClassWriter(0) 不会自动计算任何内容。您必须自己计算帧和局部变量以及操作数堆栈大小。
• 使用 new ClassWriter(ClassWriter.COMPUTE_MAXS) 为您计算局部变量和操作数堆栈部分的大小。您仍然必须调用visitMaxs，但您可以使用任何参数：它们将被忽略并重新计算。使用此选项，您仍然需要自己计算帧。
• 使用 new ClassWriter(ClassWriter.COMPUTE_FRAMES) 自动计算所有内容。您不必调用visitFrame，但仍必须调用visitMaxs（参数将被忽略并重新计算）。

使用这些选项很方便，但这是有代价的：COMPUTE_MAXS 选项会使 ClassWriter 慢 10%，而使用 COMPUTE_FRAMES 选项会使它慢两倍。这必须与自己计算所需的时间进行比较：在特定情况下，与 ASM 中使用的算法相比，通常有更简单、更快的算法来计算它，后者必须处理所有情况。

请注意，如果您选择自己计算帧，则可以让 ClassWriter 类为您执行压缩步骤。为此，您只需使用visitFrame(F_NEW, nLocals, locals,nStack, stack) 访问未压缩的帧，其中nLocals 和nStack 是局部变量的数量和操作数堆栈大小，局部变量和堆栈是包含相应的数组。类型（有关更多详细信息，请参阅 Javadoc）。

另请注意，为了自动计算帧，有时需要计算两个给定类的公共超类。默认情况下，ClassWriter 类在 getCommonSuperClass 方法中通过将两个类加载到 JVM 中并使用反射 API 来计算它。如果您生成多个相互引用的类，这可能是一个问题，因为引用的类可能尚不存在。在这种情况下，您可以覆盖 getCommonSuperClass 方法来解决此问题。
### 3.2.2 生成方法
3.1.3中的getF方法可以表示成如下，mv表示MethodVisitor：
![[Pasted image 20211026231938.png]]
第一个调用标志着字节码生成的开始。 随后是三个调用，生成此方法的三个指令（如您所见，字节码和 ASM API 之间的映射非常简单）。 必须在访问完所有指令后调用visitMaxs。 它用于为该方法的执行帧定义局部变量和操作数堆栈部分的大小。 正如我们在 3.1.3 节中看到的，每个部分的大小都是1。 最后一个调用用于结束方法的生成。
![[Pasted image 20211020224621.png]]
![[Pasted image 20211020224648.png]]
![[Pasted image 20211020231743.png]]
setF 方法和构造函数的字节码可以用类似的方式生成。 一个更有趣的例子是 checkAndSetF 方法：
![[Pasted image 20211020232843.png]]
![[Pasted image 20211020232904.png]]
![[Pasted image 20211020232914.png]]

![[Pasted image 20211026233304.png]]
![[Pasted image 20211026233315.png]]
在visitCode 和visitEnd 调用之间，您可以看到完全映射到第3.1.5 节末尾显示的字节码的方法调用：每个指令、标签或帧调用一次（唯一的例外是标签的声明和构造以及 结束标签对象）。

一个 Label 对象指定此标签的 visitLabel 调用之后的指令。 例如，end 指定 RETURN 指令，而不是紧接其后访问的帧，因为这不是一条指令。 有多个标签指定同一条指令是完全合法的，但一个标签必须只指定一条指令。 换句话说，可以使用不同的标签连续调用visitLabel，但指令中使用的标签必须使用visitLabel 只访问一次。 最后一个限制是标签不能共享：每个方法必须有自己的标签。