并发(concurrency)：同一时刻只能有一条指令执行->时间片轮询
并行(parallel)：同一时刻，有多条指令在多个处理器上同时执行

并发三特性：可见性、原子性、有序性

### 可见性
可见性原理：
![[Pasted image 20211221212331.png]]
线程结束时会把数据刷回主存
本地内存过期被淘汰后会从主存读数据

如何保证可见性：
- Thread.yield()：会释放时间片，此时保存上下文，等再次抢到时间片时，加载上下文，就会读到主存里最新的值
- volatile：storeLoad内存屏障->lock（jvm会在汇编层面在加载变量时加上lock前缀，lock不是内存屏障指令，但是有内存屏障功能，即将栈内存刷回主存，和使栈内存失效）
![[Pasted image 20211222200816.png]]
- 内存屏障UnsafeFactory.getUnsafe().storeFence()，原理同volitaile调用fence
- sychronized：底层也会调fence
- LockSupport.unpark(Thread.currentThread())，同上，也会调fence
- Thread.sleep()，同上

总结：java中保证可见性有两种办法，切换上下文和jvm层面的内存屏障

JMM模型在硬件上的体现：
![[Pasted image 20211223161408.png]]

为了解决缓存不一致的问题，采取总线窥探协议（一致性协议），常见的一致性协议如MESI
- 总线窥探：当特定数据被多个缓存共享时，处理器修改了共享数据的值，更改必须传播到所有其他具有该数据副本的缓存中
- MESI：![[Pasted image 20211223164353.png]]

在MESI协议下，保证了缓存一致性，这就是lock前缀的原理，也可以成为缓存锁定。但是不能保证原子性，比如两个线程同时执行+1操作，当前一个线程回写成功后，后一个线程会变为失效状态。
当数据跨缓存行（64Byte）时，MESI也不能保证缓存一致性。

在没缓存一致性协议之前，是靠总线仲裁锁定读写指令，保证读写指令的串行性，从而保证一致性。但是跨总线宽度的数据，比如32位系统操作64位数据时，就无法保证一致性。

再往前则是靠锁总线达成的，会锁定整个内存区，性能过低，跟单核没区别。

缓存锁定只锁定一小块缓存，而总线锁定锁定了整个缓存以及内存。

### 有序性
为什么double-check的单例要加volitail？
![[Pasted image 20211223180315.png]]
由于new对象的过程并不是原子操作，当2、3步调换顺序后，另一个线程可能会返回一个还没有初始化完成的对象。

volital保证有序性的原理是jvm层的内存屏障StoreLoad，而保证可见行加的lock是汇编层面（硬件层面）的操作：
![[Pasted image 20211223190157.png]]
在linux x86架构下只有StoreLoad是有效的

