![[Pasted image 20220228230945.png]]
singletonsCurrentlyInCreation用来判断是否发生了循环依赖。按理说aop是在2.5初始化之后进行的，会返回代理对象并放入单例池。但是如果循环依赖在第2.2步解决并返回了原始对象，就会导致赋值对象和单利池里的对象不一致。所以在2.2判断发生了循环依赖以后会立刻返回代理对象，之后就会顺利成章的把代理对象放入单例池。

![[Pasted image 20220228231450.png]]
但是如果又有一个c是循环依赖，不能再生成一次a的代理对象。所以在第一次发生循环依赖且提前生成代理对象时，会放入二级缓存earlySingletonObjects中
![[Pasted image 20220228231857.png]]

当然，如果发生了循环依赖却不用生成代理对象时，也会把原始对象放入二级缓存

如果要在圆圈处生成代理对象，那么target需要传递原始对象去代理，但是又不能从上面的划线处一直把原始对象传递过来，所以就有了第三级缓存来存原始对象