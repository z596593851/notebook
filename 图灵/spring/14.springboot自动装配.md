# Import
Import可以直接导入类，也可以导入ImportSelector，或者DeferredImportSelector。
ImportSelector无法控制导入类的顺序，例如springboot如果导入了一个默认的配置类A，并且支持如果我们后续想用自己的A去覆盖springboot的，那么即使springboot在导入时使用了@ConditionalOnMissingBean(A)也是无效的（因为我们的A会后与spring的A加载进去）。而DeferredImportSelector则有延迟加载的功能，他会在所有的@Bean和@Configuration都加载完后才去导入类。如果spring用这种方式加载A，就会检测到我们的A已经加载过了，从而不会再去加载它自己的A。DeferredImportSelector还支持分组，达到组间和组内的有序加载。

```java
public class MyImport implements DeferredImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        return new String[]{"com.xxx"};
    }

    @Override
    public Predicate<String> getExclusionFilter() {
        return null;
    }

    @Override
    public Class<? extends Group> getImportGroup() {
        return MyGroup.class;
    }

    static class MyGroup implements Group{

        AnnotationMetadata metadata;

        @Override
        public void process(AnnotationMetadata metadata, DeferredImportSelector selector) {
            this.metadata=metadata;
        }

        @Override
        public Iterable<Entry> selectImports() {
            List<Entry> list=new ArrayList<>();
            list.add(new Entry(this.metadata,"com.xxx"));
            return list;
        }
    }
}
```
当getImportGroup返回null时，从外层的selectImports加载类；当不返回null时，从指定的Group中加载类。这样当我们给我们想要加载的bean定义一个Group后，我们自己加载进去的bean则不会影响到springboot自己的内部bean的加载顺序。

# SpringBoot导入自动配置类
@SpringBootApplication->@EnableAutoConfiguration->
@Import(AutoConfigurationImportSelector.class)->getAutoConfigurationEntry->
SpringFactoriesLoader.loadFactoryNames
将所有spring.factories内的EnableAutoConfiguration类型的bean加载进来

# 实现自己的starter
创建spring.factories
![[Pasted image 20220327162140.png]]
在配置类中设置自己的生效规则：
![[Pasted image 20220327162237.png]]