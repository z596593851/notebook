![[Pasted image 20220307231800.png]]
第三、四种指的是@Autowired标记在哪个构造方法上就用哪个。当内容是"byName"时，去找方法里的"getxxx"方法，根据xxx找对应名字的bean作为入参；当内容是getType时，则找对应类型的bean作为入参；当内容是"constructor"时，由spring自己寻找参数（默认）

![[Pasted image 20220308221153.png]]
缓存在bd里的构造方法，以及构造方法的参数。这样对于原型bean，在重复getbean时就可以用到缓存。

AutowiredAnnotationBeanPostProcessor实现了推断方法，就是为了解析@Autowired标记的构造方法：
![[Pasted image 20220308222337.png]]
![[Pasted image 20220308222456.png]]
![[Pasted image 20220308223943.png]]

当autowired为constructor，或者有多个当required=false，spring会自动选择入参

如果返回null，则找是否有无参的构造方法，有则使用；
如果返回一个或多个构造方法，则去选择合适的使用：

如果有多个构造方法，则将他们按照public>private，参数多>参数小 的顺序从大到小排序，且从大到小遍历这些构造方法，（如果getbean指定了三个构造方法的参数，那么min=3，如果制定了第1个参数是xxx（从0开始），那么min=2）如果这个构造方法的实际参数个数小于min，则跳过；如果实际个数大于min，且autowired不是constructor，也会报错；否则就将构造方法的入参设置成getbean中指定的，其他没指定的参数就由spring自己去找（先根据类型再根据名字）。
![[Pasted image 20220308231502.png]]
如图，如果有三个参数的构造方法，且autowired没设置为constructor，就报错。

如果参数最多的构造方法有不止一个，那么会计算一个匹配度，返回匹配度最高的那个
严格模式下，会比较的很细节

如果可用的构造方法只有一个（且是有参的），接着走排序过程，且给他找入参

如果一个无参的和多个多参数required=false的，还是优先用多参数的，毕竟required=false代表候选

@Bean
![[Pasted image 20220308235315.png]]
![[Pasted image 20220308235405.png]]
![[Pasted image 20220308235455.png]]

如果有多个，就跟推断构造方法一样，按照参数个数排序，优先给多的那个找参数
![[Pasted image 20220308235543.png]]