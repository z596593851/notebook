# scan
Resource：读取指定路径下的类文件为Resource（这是spring自定义的读取文件的方式），进而进行asm解析，将标注了@Compoment的类，并且能够通过@Condition的类解析成BeanDefination

生成类名-先解析@Compoment的内容，再自动生成

同名beanDefination-报错

重复注册同样的Resource-略过

spring.compoments索引

# finishBeanFactoryInitialization
初始化非懒加载的bean

抽象的bd不会实例化成bean，它的子bd会继承其属性（如单例与否）

RootBd=getMerge(beanName) 这个就是合并父子bd（子bd没定义的属性就继承父的）

普通bd直接放进rootbdmap中，有parent属性的db跟parent bd合并后放入rootbdmap
之后取bd都从rootbdmap中取

getBean

implements SmartInitializingSingleton # afterSingletonsInstantiated
所有的非懒加载的单例bean都创建完后调用

# getBean
先从单例池中取
从父beanFactory中取
RootBd=getMerge(beanName) 
检查@dependsOn依赖 如果循环依赖则报错
createBean()，如果创建的是factoryBean，则调用其getObject()

scop=request时，在同一个回话里，通过相同的名字拿到的bean是同一个
先从request.getAttrabute(beanName)，如果拿不到，就创建一个放进去

bd中的beanClass最开始是类的名字(string)，只有当bean加载了，才会变成Class对象

通过beanClass（类名）生成class 并设置到bd中

实力化前
InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation
如果这一步生成了bean，那么就直接返回

实力化 doCreateBean

