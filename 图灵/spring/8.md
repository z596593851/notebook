## invokeBeanFactoryPostProcessors：调用所有的BeanFactoryPostProcessor

传入之前创建好的BeanFactorty，执行BeanFactoryPostProcessor的postProcessBeanFactory。

BeanFactoryPostProcessor不能注册bd，可以实现他的子接口BeanDefinitionRegistryPostProcessor向BeanFacotry中注册bd：
```java
public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor { 
    void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry);
}
```
![[Pasted image 20220314221315.png]]
前一个方法先执行，后一个后执行。

spring中的configurationClassPostProcessor就实现了BeanDefinitionRegistryPostProcessor来扫描并向容器中注册bd

```java
//此时还拿不到自己定义的Processor，只能拿到spring自己之前放入容器的ConfigurationClassPostProcessor

//先执行实现了PriorityOrdered的postProcessBeanDefinitionRegistry
String[] postProcessorNames =
		beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
	if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
		currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
		processedBeans.add(ppName);
	}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
currentRegistryProcessors.clear();

//再执行实现了Ordered的postProcessBeanDefinitionRegistry
postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
	if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
		currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
		processedBeans.add(ppName);
	}
}
sortPostProcessors(currentRegistryProcessors, beanFactory);
registryProcessors.addAll(currentRegistryProcessors);
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
currentRegistryProcessors.clear();
//最后再执行普通的postProcessBeanDefinitionRegistry,while是为了防止Processor又注册了Processor类型的bd
boolean reiterate = true;  
while (reiterate) {
}
//先执行BeanDefinitionRegistryPostProcessor的postProcessBeanFactory
invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);  
//再执行直接实现了BeanFactoryPostProcessor的postProcessBeanFactory 
invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
//最后执行扫描出来的BeanFactoryPostProcessor的postProcessBeanFactory 

//这之前执行的都是spring自己添加进去的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry和postProcessBeanFactory来生成BeanPostProcessor，执行到这里时已经没有可以生成processor的的processor了，只剩下前面的processor生成的BeanFactoryPostProcessor（如scan出来的自己定义的那些），此时收集并执行他们
String[] postProcessorNames =  
      beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
```

![[Pasted image 20220314223208.png]]

### configurationClassPostProcessor：解析配置类
先获取spring自己添加的bd，寻找其中的配置类。配置类满足加了@Configuration注解或者一下之一或者方法里有@Bean的方法：
![[Pasted image 20220314232610.png]]



## registerBeanPostProcessors：注册所有的BeanPostProcessor

将所有的BeanPostProcessor添加到beanFactory的beanPostProcessors中（list）