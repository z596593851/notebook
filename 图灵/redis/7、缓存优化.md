## 缓存穿透：
因为没东西，所以穿透了
![[Pasted image 20210519201454.png]]

## 缓存击穿：
单点攻击然后失效
![[Pasted image 20210519201521.png]]
用加锁来解决击穿的一种优化方案是，用tryLock代替Lock。tryLock设置超时时间，这个超时时间略大于一次业务执行的时间，这样在第一个请求执行完后，后面排队的请求都会因为tryLock失效而并行查询缓存，并且在得到结果后返回，就不用再排队串行等待锁了。这个方案的缺点是如果第一次获取锁的线程执行了很久，这期间tryLock到期，剩下的请求会击穿缓存。所以需要根据业务场景权衡。

## 缓存雪崩：
大规模失效
![[Pasted image 20220728211757.png]]

## 缓存雪崩的另一种场景：
当缓存服务由于某些原因不能提供服务（如请求过大超出承载范围，或者有大量bigkey引起性能下降）引起缓存服务超时或报错，导致大量请求直接打到存储层引起存储层宕机。

预防和解决办法：
1、保证缓存服务的高可用，比如使用带哨兵的redis主从架构，或者redis集群
2、对后端服务接口进行限流和熔断降级，如使用sentinel或hystrix
3、提前演练，在上线前模拟宕机，对可能出现的场景做预案

防止雪崩的另一种方法：多级缓存。可以在redis缓存前加一层本地map缓存，如Ehcache和guava缓存，查不到再查redis。那么更新redis缓存时也要更新本地缓存。但这样会碰到一个问题，就是当一个请求之前被缓存到了机器1里，第二次更新时却连接的是机器2，导致1里的缓存没有更新。解决方法是发mq消息让所有机器订阅，更新时一起更新。这样也会有短暂的不一致，但这种多级缓存的场景下就没必要追求如此严格的一致性了。

还有一种多级缓存的解决方案是，使用一个实时热点数据计算系统，给业务系统推送热点数据，业务系统订阅后自行进行更新。

## 数据库、缓存不一致
不一致的原因主要在于，当更新数据库后，通常会删除缓存或者更新缓存，当多个线程同时执行这种操作时，必然会由于时间差导致将旧（脏）数据写进了缓存。不管使用哪种方式，如果对数据的实时性要求不高，完全可以不做任何处理（只需要给缓存设置超时时间），这样当缓存失效后线程在查不到缓存时会查db并更新缓存，达到缓存的最终一致性。

而当对缓存的一致性有较高的要求时，可以在 ”读缓存-读不到“ 时， ”查库-更新缓存“ 前加锁。

还有一种方案是，代码里不手动更新或删除缓存，而是利用canel去更新缓存，canel会按照真实的数据库变更顺序去更新缓存。


## 其他优化
冷热隔离，即缓存命中时延长过期时间
bigkey可以进行拆分，如将list按照hash取模进行拆分

连接池预热：
![[Pasted image 20220803212419.png]]
![[Pasted image 20220803212452.png]]

key删除策略：

被动删除——当读写一个已经过期的key时，会触发被动删除，直接删掉这个key
主动删除——当redis内存超过设置的maxmemory时触发主动删除。主动删除策略有以下8种：

![[Pasted image 20220803212909.png]]
![[Pasted image 20220803213341.png]]

布隆过滤器