分布式锁优化：分段锁

冷热分离：给缓存加过期时间，用到的续期

不存在的商品也设置缓存，并设置过期时间为几分钟；相同的商品id也延期。

缓存击穿-加锁，一种优化方案是，用tryLock代替Lock。tryLock设置超时时间，这个超时时间略大于一次业务执行的时间，这样在第一个请求执行完后，后面排队的请求都会因为tryLock失效而并行查询缓存，并且在得到结果后返回，就不用再排队串行等待锁了。这个方案的缺点是如果第一次获取锁的线程执行了很久，这期间tryLock到期，剩下的请求会击穿缓存。所以需要根据业务场景权衡。

![[Pasted image 20220801214937.png]]

防止雪崩的另一种方法：多级缓存。可以在redis缓存前加一层本地map缓存，查不到再查redis。那么更新redis缓存时也要更新本地缓存。但这样会碰到一个问题，就是当一个请求之前被缓存到了机器1里，第二次更新时却连接的是机器2，导致1里的缓存没有更新。解决方法是发mq消息让所有机器订阅，更新时一起更新。但是这样也会有短暂的不一致，需要取舍。

# 数据库、缓存不一致
![[Pasted image 20220801210127.png]]
在 查数据库-更新缓存 和 更新数据库-删缓存 这两个操作之前都先加锁。
![[Pasted image 20220801210918.png]]
注意，只有读不到缓存时才加锁，所以平时是不用加锁的。读多写少的场景可以优化成读写锁，使得缓存为空时也能并发读。
对于同一个key，如果先加了redisson的写锁，再加读锁，读锁是可以重入的。