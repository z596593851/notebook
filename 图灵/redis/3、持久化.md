# RDB
```shell
save 900 1
save 300 10
save 60 10000
```
save <指定时间间隔> <执行指定次数更新操作>，满足条件就将内存中的数据同步到硬盘中。官方出厂配置默认是 900秒内有1个更改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的数据快照写入磁盘。

## 优点：  
1 RDB是一个非常紧凑的文件（压缩过的二进制数据），适合大规模的数据恢复，要比RDB快。  
2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。

## 缺点：  
1、数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。  
2、备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件。所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。

## save与bgsave
save与bgsave：save是同步执行的，持久化时会阻塞其他redis命令，但不会消耗额外内存；bgsave是异步的，不阻塞其他redis命令，但是会fork子进程，消耗内存，此时如果有新的修改命令，会同时修改内存数据与RDB中的数据，即写时复制。redis默认使用bgsave

# AOF
Redis默认是不使用该方式持久化的。Aof方式的持久化，是每操作一次redis数据库，都将操作的指令储到aof持久化文件中。

## AOF文件刷盘策略
![[Pasted image 20220721204000.png]]

## AOF重写
由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。例如如下指令：
```
sadd animals "cat"
sadd animals "dog" "panda" "tiger"
srem animals "cat"
sadd animals "lion" "cat"

```
如果使用AOF 重写，那么AOF 文件中将只会保留下面一条命令：
```
sadd animals "dog" "tiger" "panda" "lion" "cat"
```

### AOF重写时机
```shell
//第一次重写时需达到的最小文件大小
auto-aof-rewrite-min-size 64mb

//自上一次重写后文件增长了100%则再次触发重写
auto-aof-rewrite-percentage 100
```

## AOF 的优缺点

优点：数据的完整性和一致性更高  
缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。

在使用aof和rdb方式时，如果redis重启，则数据从aof文件加载。

# RDB与AOF混合模式
一开始先增量写AOF，写到appendonly.aof中。触发重写时，先开辟一个临时文件，将这一时刻之前的所有持久化AOF数据压缩成RDB，并且将压缩时新增的AOF数据仍以AOF格式追加到RDB后，压缩完成后将临时文件替换原有AOF文件，接着写AOF数据，直到触发下一次重写。混合持久化AOF文件结构如下：
![[Pasted image 20220822215033.png]]
一部分是二进制RDB格式数据，一部分是指令AOF格式数据。混合模式建立在aof开启的前提下，混合持久化的触发时机是aof重写时。

所以在混合模式下，redis重启时会先家在RDB中的内容，然后再重放AOF日志，从而代替之前的AOF全量重放，重启效率大大提升。

# RDB和AOF对比
RDB是全量的，AOF是增量，RDB记录的是压缩过的二进制数据，AOF记录的是修改命令