# 常用场景
缓存、分布式锁、计数、session共享、购物车（hash）

hash结构在redis集群架构下不友好，会造成数据倾斜，最好分片存储

list可以实现栈、队列、阻塞队列

# list使用场景：feed流
push的方式实时性高，但是粉丝过多时会影响实时性，且存储成本过大，因为可能会有大量僵尸号
pull的方式可以在用户登陆时拉一次，可以避免push的弊端，但是实时性差。
所以可以结合以上两种，给在线的粉丝push，离线的粉丝登陆时pull。


# set使用场景：抽奖、点赞、社交模型
抽奖
![[Pasted image 20220720214136.png]]
点赞
![[Pasted image 20220720214505.png]]
关系模型

共同关注：取交集
我可能认识的人：我关注的人关注的，我没关注的人。拿我关注的人的集合，与我关注的人的关注集合，取差集
我关注的人也关注他：遍历我的关注人的关注列表，查看他在谁的列表里
![[Pasted image 20220720215144.png]]

# zset使用场景：排行榜
![[Pasted image 20220720215834.png]]

![[Pasted image 20220721200006.png]]
用scan扫描所有key：
![[Pasted image 20220721201148.png]]
![[Pasted image 20220721201456.png]]
save与bgsave：save是同步执行的，持久化时会阻塞其他redis命令；bgsave是异步的，不阻塞其他redis命令，此时如果有新的修改命令，会同时修改内存数据与RDB中的数据，即写时复制。redis默认使用bgsave
![[Pasted image 20220721203244.png]]

RDB是全量的，AOF是增量，RDB记录的是压缩过的二进制数据，AOF记录的是修改命令

aof策略：
![[Pasted image 20220721204000.png]]

aof重写时机：
![[Pasted image 20220721204616.png]]

aof重写也会fork一个子线程执行，就像bgsave，不会阻塞主线程

RDB与AOF的混合模式：
![[Pasted image 20220721205521.png]]
混合模式建立在aof开启的前提下，混合持久化的触发时机是aof重写时。

主从同步过程：
![[Pasted image 20220721211207.png]]

如果从节点挂了，断点续传：从节点拿着最后一次接收到的偏移量去主节点的最近缓存里找；如果缓存里没有offset，则全量回复。缓冲区有大小限制，先进先出
![[Pasted image 20220721211733.png]]

主从风暴：
![[Pasted image 20220721212112.png]]

管道操作不支持事务，即如果中间有报错的指令，并不会回滚所有指令。redis的multy操作虽然支持事务，但是比较鸡肋。可以用lua脚本实现事务：
![[Pasted image 20220721213506.png]]

三个哨兵监听一个主节点，并从主节点上拉取从节点的信息。哨兵就相当于注册中心，当配置了哨兵后，客户端就不直接与redis交互，而是通过哨兵获取redis的ip，进而与redis交互。