# 容错
![](https://oscimg.oschina.net/oscnet/d45309bcb942d63093f1cff425662996921.jpg)
1. 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽；
2. 节点的fail是通过集群中**超过半数的节点检测**失效时才生效；
3. 如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的\[0-16383\]slot映射不完全时进入fail状态；
4. 如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。

集群之间的数据同步方式有两种，集中存储和gossip：
集中式的优点是同步快，缺点是压力集中在了一个地方（如zk，所有主节点都保存了完整的副本，一旦一个主节点上的数据有新增，就会同步广播到所有主节点上）
gossip的优点在于数据比较分散，降低了压力；缺点是有延迟，非强一致，最终一致
![[Pasted image 20220725214343.png]]

由于redis是gossip式，所以集群不建议搞太多节点，容易导致延迟。redis集群内部通信端口是对外端口+10000

## 集群选举过程
![[Pasted image 20220725215456.png]]
![[Pasted image 20220725215910.png]]

## 集群脑裂
指的是由于网络分区导致部分节点割裂出去并且选举出了master，那么同时就有多个master对外提供写服务，当分区恢复后，其中一个master要恢复为slaver，导致丢数据。
对于redis集群来讲，由于有过半机制，即使出现了网络分区也不会选举出新的master；但是对于主从redis架构来讲是有可能出现的。这时需要设置：
```shell
min-slaves-to-write=1 //写数据最少需要同步的slaver数量
```
如下图，假如redis主从有5个节点（2 master 3 slaver），那么这个数量可以设置为2（加上主节点为3，来模仿半数），当右下角分区，由于超过半数节点，会选举出新的master；而左上角原有master由于不到半数，会退化为slaver。总之分区后集群仍然只有一个master。
![[Pasted image 20220823225158.png]]
![[Pasted image 20220726203742.png]]
缺点是，如果一个集群的主节点超过半数的从节点挂掉，那么这个集群就不可用了。这就相当于牺牲了可用性来换取一致性。
![[Pasted image 20220726204729.png]]

# 槽位
Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点
![[Pasted image 20220725211051.png]]
集群信息
![[Pasted image 20220725210908.png]]
![[Pasted image 20220725211304.png]]
即使在当前机器set值，也可能被存入其他机器：
![[Pasted image 20220725212028.png]]
但是取值时不能直接从物理机上取，可能取不到，需要用jedis或者spring-redis。jedis客户端在初始化时会缓存一份集群的槽位-ip对照关系表，在执行get、set命令时会通过计算key的hash值与16384取模，然后根据关系表去对应的机器上进行操作。

# 主从与集群
集群可以一定程度缓解访问瞬断。主从结构的redis当主节点挂掉，从节点还没来得及顶上时，整个redis服务处于不可用状态；但集群结构的redis当某个主节点挂掉从节点顶上前，也只会影响这个节点内的数据访问，不会影响其他节点的访问。

主从的qps和存储上限受限与主节点，而集群可以大大提升qps和存储上限制。




