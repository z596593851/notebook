原子性：undo日志，记录事务内数据的变更，以便事务的回滚
一致性，
隔离性：锁+mvcc
持久性：redo日志

脏页为什么不直接落盘：
可能只改了几条，但会导致一整页的刷新；
随机io性能差

# redo日志
redo日志格式
![[Pasted image 20220202213017.png]]
type：有53种
space id：表空间id
page number：页号

redo log buffer的刷盘时机：
容量超过一半
事务提交
每秒
服务器关闭时

redo log日志在磁盘上有两个文件，ib_logfile0和ib_logfile1，默认每个48M，都写满了就重新覆盖写。

innodb_flush_log_at_trx_commit

Log Sequence Number：每条redo日志都有对应的lsn，mysql可以根据lsn得知当前redo日志的数量，以及哪些redo日志已经刷盘。
![[Pasted image 20220203003707.png]]

# undo日志
记录了当前数据所处事务的事务id，以及当前数据对应的undo日志，所以可以根据undo日志在事务失败时回滚当前事务内的所有操作。
![[Pasted image 20220202224222.png]]

## insert操作
当插入一条数据时，会同时更新聚簇索引和二级索引，但是只用主键id产生一条undo日志就可以了，不需要再用二级索引产生undo日志，因为二级索引里也记录着主键id。

## delete操作
删除时，先将delete_mask置为1，等事务提交后，再将记录从链表删除，添加到page_free中。
![[Pasted image 20220202230244.png]]
![[Pasted image 20220202230258.png]]
![[Pasted image 20220202230313.png]]

## update操作
不更新主键：
1.如果更新操作不会改变变长字段的大小，那么就地更新
2.如果改变了，则先删掉旧记录（直接从链表中转移到page_free中），再插入新记录

更新主键：
1.将旧记录进行delete操作
2.创建新纪录

# undo log、redo log的顺序
![[Pasted image 20220203001440.png]]

# mysql数据恢复
mysql异常关闭，如果事务还未提交，则使用undo log对事务进行回滚；如果事务已经提交，则使用redo log恢复数据。

为何不用binlog恢复？因为binlog属于逻辑日志，记录了某条sql对某行记录的影响，是偏业务角度的日志，主要用来人工恢复数据，无法根据binlog判断某些数据是否真的落盘了；而redo log是偏物理层面的日志，可以反映出某条数据是否落盘