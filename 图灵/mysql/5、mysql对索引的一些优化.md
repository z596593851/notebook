# MRR
在mysql5.6之前，对于范围查询这种离散读的行为，即使查询字段有索引，如果查询量过大，mysql仍然会选择聚簇索引进行全表扫描。如 name>'0' and name <'z'，虽然二级索引是有序的，但是它关联的聚簇索引却是无序的，需要进行多次随机io的回表操作，增加了io开销。
在mysql5.6之后，加入了MRR即多范围读取优化，当对二级索引进行范围查找时，而MRR会先查一部分二级索引，在内存中将这部分二级索引关联的聚簇索引进行排序后，再集中进行一次顺序io的回表，大大增加了效率。
![[Pasted image 20220129222255.png]]

# 索引合并
一般情况下mysql在一次查询中只会用到单个二级索引，特殊情况下会用到多个，称为索引合并。

## 交集合并
前提：
1. 二级索引必须是等值查询
2. 主键索引可以是范围查询
```shell
select * from table where name='a' and address='b'

select * from table where id<10 and name='a'
```
当二级索引的多个等值查询会分别查出过多结果时，比起先通过一个条件的结果回表查出结果集，再从结果集中过滤剩余条件，mysql会先在二级索引树中求出所有等值查询结果的id（主键索引）的交集，从而得出更小的结果集，再去回表。

## 并集合并
前提：
1. 二级索引必须是等值查询
2. 主键索引可以是范围查询
3. 搜索条件的部分使用交集合并得到的集合，与其他方式得到的集合，取并集
```shell
select * from table where sex=1 or (name='a' and address='b')
```
(name='a' and address='b')使用交集合并的结果，与sex=1进行并集合并，最后进行回表。

## 排序并集合并
并集合并要求是等值查询，当不是等值查询时，如：
```shell
select * from table where name>'a' or address<'b'
```
mysql会将 name>'a' 的id进行排序，然后将 address<'b' 的id排序，最后将二者合并进行回表。

当满足索引合并的条件时也不一定会执行，仍然取决于优化器的判断。但当进行了索引合并，会在执行计划的extra中体现出来：Using intersect(...)、Using union(...)、Using sort_union

其实完全没有必要进行索引合并，只需建立联合索引就可以更高效的进行查询。

# ICP
即Index Condition Pushdown索引下推

在MySQL5.6之前，当进行查询时首先根据索引来查找记录，然后再根据WHERE条件来过滤记录。在支持ICP后，MySQL数据库会在取出索引的同时，判断是否可以进行WHERE条件的过滤，也就是将WHERE的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取（fetch），从而提高数据库的整体性能。
![[Pasted image 20220127173920.png]]
按照常识，这条sql用到的索引会止步在name，但是执行计划却显示用到了所有索引。索引下推是5.6引入的，在这之前执行这条sql时，会先拿到所有 LiLei% 的结果的主键id，再去回表拿到完整的数据，最后再去比对age和position；而5.6以后会直接在 LiLei% 结果集的基础上直接比对age和position。

# FIC
mysql5.5之前，对索引进行添加或删除时的过程为：
- 首先创建一张新的临时表， 表结构为通过命令ALTER TABLE新定义的结构
- 然后把原表中数据导入到临时表
- 接着删除原表
- 最后把临时表重命名为原来的表名

由于要迁移数据，当修改一张大表时时间就会很长，并且这段时间内数据库服务不可用。

5.5之后，InnoDB开始支持一种称为Fast Index Creation （快速索引创建） 的索引创建方式——简称 FIC。对于主键索引的创建删除还是沿袭之前的做法，但是对于普通索引的创建， InnoDB存储引擎会对创建索引的表加上一个S（读）锁 。在创建的过程中，不需要重建表，因此速度较之前提高很多，并且数据库的可用性也得到了提高。删除辅助索引操作就更简单了，删除辅助索引比较简单，只会更新innodb内部系统表和mysql数据字典，来表明该索引已经不存在。innodb会归还该索引占用的存储空间。

MySQL 5.6版本开始支持Online DDL（在线数据定义）操作，其允许辅助索引创建的同时，还允许其他诸如INSERT、UPDATE、DELETE这类DML操作，这极大地提高了MySQL数据库在生产环境中的可用性。
不仅是辅助索引，以下这几类DDL操作都可以通过“在线”的方式进行操作：辅助索引的创建与删除、改变自增长值、添加或删除外键约束、列的重命名。
InnoDB存储引擎实现Online DDL的原理是在执行创建或者删除操作的同时，将INSERT、UPDATE、DELETE这类 DML操作日志写入到一个缓存中。待完成索引创建后再将重做应用到表上，以此达到数据的一致性。这个缓存的大 小由参数innodb_online_alter_log_max_size控制，默认的大小为128MB。 需要特别注意的是，由于Online DDL在创建索引完成后再通过重做日志达到数据库的最终一致性，这意味着在索引创建过程中，SQL优化器不会选择正在创建中的索引。

# 自增
在InnoDB引擎中，对每个含有自增长字段的表都有一个自增长计数器，插入操作会基于这个值加一。增长时会加AUTO-INC Locking，这种锁其实是一种特殊的表锁，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放。这种锁在并发插入和insert..select大数据量插入时性能较差。

从MySQL 5.1.22版本开始，InnoDB存储引擎中提供了一种轻量级互斥量的自增长实现机制，这种机制大大提高了自增长值插入的性能。并且从该版本开始，InnoDB存储引擎提供了一个参数innodb_autoinc_lock_mode来控制自增长的模式，该参数的默认值是1。
![[Pasted image 20220427201458.png]]
![[Pasted image 20220427201546.png]]
简言之，1会保证自增长列的连续性，而2不能保证。