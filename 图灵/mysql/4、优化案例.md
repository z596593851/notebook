# 1、覆盖索引
![[Pasted image 20220127160638.png]]
1是all，2是index。如果无法避免%abc%这种模糊查询，最好一次性把要用到的字段都在select中指明，并且加上联合索引防止回表（即覆盖索引）。

```shell
EXPLAIN select * from employees where name > 'a';
```
![[Pasted image 20220127193741.png]]
如果用name索引需要遍历name字段联合索引树，然后还需要根据遍历出来的主键值去主键索引树里再去查出最终数据，成本比全表扫描还高，可以用覆盖索引优化，这样只需要遍历name字段的联合索引树就能拿到所有结果，如下：
```java
EXPLAIN select name,age,position from employees where name > 'a' ;
```
![[Pasted image 20220127194240.png]]
# 2、强制索引
在有联合索引 (name、age、position) 的情况下
![[Pasted image 20220127172017.png]]
可能不会走索引，以为mysql优化器认为不走索引比走索引快。这种情况下可以使用force index强制走索引
![[Pasted image 20220127172114.png]]
但最好的解决方法是使用覆盖索引进行优化
![[Pasted image 20220127172521.png]]

# 3、索引下推
![[Pasted image 20220127173920.png]]
按照常识，这条sql用到的索引会止步在name，但是执行计划却显示用到了所有索引。索引下推是5.6引入的，在这之前执行这条sql时，会先拿到所有 LiLei% 的结果的主键id，再去回表拿到完整的数据，最后再去比对age和position；而5.6以后会直接在 LiLei% 结果集的基础上直接比对age和position。

# 4、order by / group by
![[Pasted image 20220127201012.png]]
order by是否用到了索引不会体现在key_len中，而是会体现在extra，只要extra不是using filesort就代表用到了索引。

![[Pasted image 20220127201419.png]]
where用到了name索引，但是order by由于跳过了age，所以没走索引。

![[Pasted image 20220127201629.png]]
order用到了索引

![[Pasted image 20220127201708.png]]
对于order by，顺序不能调换

# 5、Using filesort
using index是使用普通索引树进行排序，using filesort是使用聚簇索引树进行排序。using filesort又分为单路排序和双路排序：
- 单路排序：一次性取出满足条件的所有字段，然后在sort buffer中进行排序
- 双路排序：只取出相应的排序字段，和可以直接定位数据行的行id，然后在sort buffer中进行排序，排序完后再取出其他需要的字段。

MySQL 通过比较系统变量 max_length_for_sort_data(默认1024字节) 的大小和需要查询的字段总大小来判断使用哪种排序模式。
- 如果 字段的总长度小于max_length_for_sort_data ，那么使用单路排序模式；
- 如果 字段的总长度大于max_length_for_sort_data ，那么使用双路排序模式。

# 6、索引设计原则
1、代码先行，索引后上
2、联合索引尽量覆盖条件
比如可以设计一个或者两三个联合索引(尽量少建单值索引)，让每一个联合索引都尽量去包含sql语句里的where、order by、group by的字段，还要确保这些联合索引的字段顺序尽量满足sql查询的最左前缀原则。
3、长字符串我们可以采用前缀索引
4、where与order by冲突时优先满足where
一般这种时候往往都是让where条件去使用索引来快速筛选出来一部分指定的数据，接着再进行排序。因为大多数情况基于索引进行where筛选往往可以最快速度筛选出你要的少部分数据，然后做排序的成本可能会小很多。