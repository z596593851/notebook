# 分页优化
根据自增且连续的主键排序分页的查询：
```shell
select * from employees limit 90000,5;

select * from employees where id > 90000 limit 5;
```

根据非主键排序的分页查询：
```shell
select * from employees ORDER BY name limit 90000,5;
```
![[Pasted image 20220127231713.png]]
扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引。
所以关键是让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录：
```shell
select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id;
```
![[Pasted image 20220127231840.png]]
其实就是将内查询用覆盖索引优化。

# join
```shell
//t1 10000行，t2 100行
select * from t1 inner join t2 on t1.id= t2.id;
```
如果连接字段有索引，会使用嵌套循环连接 Nested-Loop Join(NLJ) 算法:
一次一行循环地从驱动表t2（对于join，小表是驱动表；对于left join，左表是驱动表）中取数据与t1比对，取出满足条件的行。t2扫描了一遍，是100行，由于t1的id是索引，所以t1也扫描了100行，一共扫描了200行。

如果连接字段无索引，会使用基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法：
把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比。将t2读取到join_buffer（内存）中，扫描了100行，在与t1做对比时，由于没有索引，所以扫描了一遍t1 10000行，一共扫描了10100行，但是在内存中进行了100\*10000=100w次对比。但是此时用第一种方法进行连接，那么会扫描100\*10000=100w次。

# in和exsits优化
原则：小表驱动大表，即小的数据集驱动大的数据集。

in：当B表的数据集小于A表的数据集时，in优于exists
```shell
select * from A where id in (select id from B)
#等价于：
for(select id from B){
  select * from A where A.id = B.id
}
```

exists：当A表的数据集小于B表的数据集时，exists优于in：
```shell
select * from A where exists (select 1 from B where B.id = A.id)
 #等价于:
for(select * from A){
  select * from B where B.id = A.id
}
```

- EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换,官方说法是实际执行时会忽略SELECT清单,因此没有区别
- EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比
- EXISTS子查询往往也可以用JOIN来代替，何种最优需要具体问题具体分析
