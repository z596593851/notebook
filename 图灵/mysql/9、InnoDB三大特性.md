# 数据库三范式
[[数据库范式]]

# InnoDB三大特性
## 1.双写缓冲区 
占系统表空间的两个区，即2MB。Mysql每次向系统写入一页（16KB）数据，但是操作系统每次向磁盘写入的数据是4KB，所以要写4次。中间只要有一次写入错误，这一页都会出错。

![[Pasted image 20220201233006.png]]

Mysql先将数据从BufferPool写入内存的DoublewriteBuffer，再从内存的DoublewriteBuffer向磁盘的DoublewriteBuffer写入，成功后再写入表空间。

Mysql异常关闭时，如果磁盘的DoublewriteBuffer写成功了，就用其中的数据来恢复表数据（整页恢复）；如果DoublewriteBuffer也写失败了，就用表空间的原始数据（如果是插入操作那就是插入前的数据，更新操作就是更新前的数据）结合redo log（重做日志）逐条恢复DoublewriteBuffer，这个效率肯定低于从DoublewriteBuffer进行恢复。
![[Pasted image 20220424192427.png]]

## 2.自适应哈希索引
InnoDB存储引擎如果监控到某个索引经常用，那么就认为是热数据，然后内部自己创建一个hash索引，称之为自适应哈希索引，创建以后，如果下次又查询到这个索引，那么直接通过hash算法推导出记录的地址，直接一次就能查到数据，比重复去B+tree索引中查询三四次节点的效率高了不少。

InnoDB存储引擎使用的哈希函数采用除法散列方式，其冲突机制采用链表方式。注意，对于自适应哈希索引仅是数据库自身创建并使用的，我们并不能对其进行干预。通过命令show engine innodb status 可以看到当前自适应哈希索引的使用状况。

![[Pasted image 20220129232444.png]]

同时在MySQL 5.7中，自适应哈希索引搜索系统被分区。每个索引都绑定到一个特定的分区，每个分区都由一个单独的 latch 锁保护。

## 3.Buffer Pool
![[Pasted image 20220428205057.png]]
![[Pasted image 20220202003649.png]]

所有的增删改查都直接操作BufferPool，如果BufferPool中没有数据时，再从磁盘中读取。
磁盘数据被读到BufferPool后，在BufferPool中也是以页的方式进行组织，每页都有一个对应的控制块，控制块以链表的形式进行组织：
![[Pasted image 20220202000706.png]]

BufferPool中的控制块被两种链表所管理：

1、空闲的页对应的控制块连接成free链表，使用后从链表移除

2、有过更新操作的脏页对应的控制块连接成flush链表
脏页向磁盘刷盘的时机：后台线程定时刷盘、BufferPool内存紧张。

由于select操作而读取到BufferPool中的页对应的控制块，由LRU管理。如果一个区（64个页）中有56个页被连续访问过，或者有13个页被随机访问过，那么mysql会将整个区预读进BufferPool。由于mysql会将对一个页里一条数据的访问视为对这个页的一次访问，所以全表扫描会使得大量的页的访问次数激增，从而导致缓存被更新，原本很热的区域被挤掉，而这种更新在业务上是不期望看到的。所以mysql在传统的LRU上进行了改进，将链表分为了yong（热区） 和 old（冷区）两部分（冷占37%），第一次加载的表会被放到old区的前面，而不会影响到yong区。但是仅仅这样还是无法避免全表扫描对热区的影响。所以mysql还会计算第一次和最后一次访问某个页的时间差，如果小于1s则被视为在全表扫描，仍然会被放在old区。


线程安全问题：多实例（1-64个），每个大小是之前设置的size/设置的个数。官网推荐个数是，总大小/个数>=1G，但当总大小不足1G时，只能设置1个。

默认128M，偏小，最好设置成60%的机器物理内存大小，官方推荐80%

change buffer：BufferPool是当对聚簇索引做修改时的优化，当对二级索引做了更改，会利用change buffer做优化



