# GC停顿以及SafePoint

GC停顿（Stop The World）的原因是，在进行垃圾回收时，需要做可达性分析。在枚举那些可以作为GC Root的类时，不可以出现对象引用关系还在发生变化的情况，这就是导致GC进行时必须停止所有java执行线程的一个重要原因，即使是号称几乎不会发生停顿的CMS收集器，枚举根节点时也是必须要停顿的。发生停顿的这个点叫做SafePoint。

可作为GC Root的对象主要在全局引用和执行上下文中，逐个检查会消耗很多时间。HotSpot中一个叫做OopMap的数据结构，直接存放了对象引用的地址。在OopMap的帮助下可以快速准确的完成GC Root的枚举。但是导致对象引用关系变化（或者说导致OopMap内容变化）的指令有很多，不可能为每一条指令都生成OopMap，只是在特定位置记录了这些内容，这些特定的位置就是SafePoint。

SafePoint的选取标准是那些会导致程序长时间执行的指令，比如方法调用、循环跳转、异常跳转等，这些指令才会产生SafePoint。

需要执行GC时，线程不会立刻中断，而是执行到下一个安全点才中断。当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个 线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。

# Serial
单线程，且在进行垃圾收集的时候必须停止其他线程；用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法；简单高效，单CPU环境下没有线程开销，仍可用在Client模式下的新生代。

![[Pasted image 20220207184833.png]]

# Parnew
多线程收集器，用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法，可以和CMS配合使用。

# Parallel
多线程收集器，在发生回收时停止用户线程；用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法。JDK8默认的垃圾收集器，在内存较小时好用，内存较大时STW时间较长。

Parallel的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，即尽量缩短垃圾收集的总时长。

优点：吞吐量高，即垃圾收集总时长较短
缺点：STW停顿时间较长。

![[Pasted image 20220207185217.png]]
![[Pasted image 20220510204510.png]]


# CMS
JDK1.5发布，旨在缩短垃圾收集的停顿时间，垃圾回收和用户线程可以并发执行，采用 “标记-清除” 算法，常用在老年代。其垃圾回收经历四个步骤：

-   初始标记：只是标记一下GC Roots能直接关联到的对象，速度很快
-   并发标记：会深入查找GC Roots关联到的对象，比较耗时
-   重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记，这个过程的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短
-   并发清除
-   并发重置：清除标记

优点：STW停顿时间较短（吞吐量较小），因为最耗时的并发标记是和用户线程一起执行的。

缺点：
- 垃圾收集总时长较长
- 耗费CPU资源（并发标记和并发清理会和用户进程抢夺资源）
- 无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理)
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数- XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理
- 可能会触发“并发失败”，即并发标记或并发清理过程中，如果又有超出了老年代剩余空间大小的对象进来，会强制stop the world，用serial old垃圾收集器来专心做垃圾回收。

![[Pasted image 20220207190103.png]]

如果初始标记过程中不STW，那么在枚举GC Root的过程中，已经被视为垃圾的对象可能会又被其他对象所引用而变为正常的对象，然后被误清除；或者标记过程中可能一直会有新的对象产生，导致GC Root的枚举无法结束。

CMS核心参数：
1. -XX:+UseConcMarkSweepGC:启用cms  
2. -XX:ConcGCThreads:并发的GC线程数  
3. -XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩整理(减少碎片)  
4. -XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一 次  
5. -XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC(默认是92，这是百分比) 6. -XX:+UseCMSInitiatingOccupancyOnly:只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设 定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整  
7. -XX:+CMSScavengeBeforeRemark:在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段  
8. -XX:+CMSParallellnitialMarkEnabled:表示在初始标记的时候多线程执行，缩短STW  
9. -XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行，缩短STW;

## CMS垃圾收集算法的实现——三色标记法
- 黑色：表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过，它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。
- 灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。
- 白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。

![[Pasted image 20220208160757.png]]

## CMS是如何保证并发标记阶段能和用户线程共同进行的？
多标的无所谓，可以视为浮动垃圾，下次再清理；漏标的采用增量更新来解决。而G1采用原始快照SATB解决。

### 多标
如果在并发扫描之前，某个对象有到GCRoot的引用，但是扫描之后这个引用又被删除了，或者GCRoot被删除了，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。

另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。

### 漏标
漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： 增量更新（IncrementalUpdate） 和原始快照（Snapshot At The Beginning，SATB）。

增量更新：就是当黑色对象插入新的指向白色对象的引用关系时（比如并发标记已经结束，一个黑色对象又插入了一个对白色对象的引用）， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。

原始快照：就是当灰色对象要删除指向白色对象的引用关系时（比如并发标记还未结束，一个灰色对象指向的白色对象还没来得及被扫描到就要被删除了）， 就将这个要删除的引用记录下来， 在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色（目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾）

以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障（类似于AOP）实现的：
```java
void oop_field_store(oop* field, oop new_value) {
    // 写屏障‐写前操作 
    pre_write_barrier(field);
    *field = new_value; 
    // 写屏障‐写后操作
    post_write_barrier(field, value); 
}
```
写屏障实现SATB：
```java
void pre_write_barrier(oop* field) {
    oop old_value = *field; // 获取旧值
    remark_set.add(old_value); // 记录原来的引用对象
}
```
写屏障实现增量更新：
```java
void post_write_barrier(oop* field, oop new_value) {
    // 记录新引用的对象
    remark_set.add(new_value);
}
```

### 卡表
当进行一次局限于年轻代的垃圾收集时，新生代中的对象是完全有可能被老年代对象引用的，这样在进行GCRoot可达性分析时，除了对原有的节点进行枚举外，还要枚举整个老年代，大大降低了效率。反过来也一样。

为了不全量扫描老年代，新生代引入了“卡表”这种字节数组，数组的每个元素对应着老年代一个特定大小的内存区域，称为“卡页”，如果某个卡页中有指向新生代的引用，那么这个卡页就是一个“脏页”，在做可达性分析时就会将这块区域也纳入扫描范围。

# G1
![[Pasted image 20220208174320.png]]
G1将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region。一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M。

默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个 Region，可以通过“-XX:G1NewSizePercent”设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多 的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”调整。年轻代中的Eden和 Survivor对应的region也跟之前一样，默认8:1:1。 一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能 可能会动态变化。

垃圾回收的过程：
-   初始标记
-   并发标记
-   最终标记
-   筛选回收

![[Pasted image 20220208180952.png]]

优点：
-   并发回收，和用户线程同时执行，低停顿；
-   不用和其他收集器配合，独自管理新生代和老年代；
-   采用“ 标记-整理 ”算法，不会产生碎片；
-   可控的STW时间，在规定时间内优先回收价值大的区域

## 为什么G1有可控的STW时间
- Region作为单次回收的最小单元，即每次收集 到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集；
- 在规定时间内优先回收价值大的区域。

## YoungGC
YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills（最大停顿时间） 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC。

## MixedGC
不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent，默认45%)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC。

## Full GC
停止系统程序，然后采用单线程进行标记、清理和压缩整理，清理出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)

## G1收集器适用于大内存（8G以上）
高并发系统中，大部分对象都是朝生夕死的，所以最好调高新生代的大小，比如32G，64G。这时如果还使用CMS收集器，那么yong GC的时间以及停顿时间会过长。而G1收集器由于可以控制垃圾收集的时间，所以更适合这种场景。

## 跨代引用
G1的各region之间也可能存在跨代引用的情况，也是通过卡表的方式解决的。

![[Pasted image 20220207182958.png]]