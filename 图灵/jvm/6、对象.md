# 对象的内存结构
![[Pasted image 20220510173957.png]]
![[Pasted image 20220104173315.png]]

64位操作系统默认开启了指针压缩，如果不压缩，那么KlassPoint（以及其他指针类型的数据）会占8个字节，压缩后占4个字节（32位），这样一行就可以放两个指针了。32位的操作系统寻址空间是4G（2的32次方），64位操作系统的寻址空间是4x2的32次方G。
当堆内存大于32G时，压缩指针会失效

所以一个new Object()占16字节（对象头12字节+填充位4字节，jvm要求对象的地址是8的整数倍）

sychronized对象锁底层依赖monitor对象，即每个锁对象对应一个monitor对象，锁对象会把指向monitor对象的指针存放在mark word中。

mark word中存储的锁信息：

![[Pasted image 20220104190745.png]]

# 对象是如何被访问到的
![[Pasted image 20220510174633.png]]
java方法栈的本地变量表记录了对象的直接引用地址reference，指向了对象在堆中的位置。如果还需要访问对象的类型数据，则再次访问对象头中的klass point。

# 对象的内存分配
## 逃逸分析
就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，称为方法逃逸，例如作为调用参数传递到其他地方中，也可能被其他线程访问，称为线程逃逸。

## 栈上分配
如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。

## 标量替换
通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解成若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。标量替换可以视作栈上分配的一种特例，实现更简单(不用考虑整个对象完整结构的分配)， 但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。
```java
public class Point{
	int x;
	int y;
}

private static String alloc() {
	Point point = new Point(1,2);
	return point.toString();
}

public static void main(){
	int i=0;
	while(i<50000){
		alloc();
	}
}
```
以上方法中的Point对象会以标量分配的方式在栈内分配。

# new对象的过程
一、类加载-![[1、类加载#类加载过程]]
二、创建对象
1. 在堆区分配对象需要的内存（指针碰撞法或空闲列表法）
-   指针碰撞，当虚拟机使用复制算法或标记整理算法实现的垃圾收集器时，内存区域都是规整的，这时候使用指针碰撞分配内存，用过的内存放在一边，空闲的内存在另一边，中间用一个指针作为分界点，当需要为新对象分配内存时只需把指针向空闲的一边移动一段与对象大小相等的距离。
-   空闲列表，当虚拟机使用标记清除算法实现的垃圾收集器时，内存都是碎片化的，那虚拟机就要记录哪块内存是可用的，当需要分配内存时，找一块足够大的内存空间给对象实例，并更新记录。
2. 对所有实例变量赋默认值
3. 执行实例初始化代码。初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法

在分配内存时可能有并发问题，用cas或者TLAB解决。TLAB即本地线程分配缓冲，就是每个线程都会预先在堆上申请一块空间，需要new对象时每个线程就在各自的堆空间上分配。