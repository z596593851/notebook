# ZGC概述
## 特点
JDK11推出
支持16TB级别的堆
停顿时间不超过1ms，不会随着堆大小的增加而增加

## 内存布局
![[Pasted image 20220713215458.png]]
无分代，分成小、中、大三种页面，这是因为linux2.6引入标准大页，如果内存是GB级别，那么用2M来分页，如果是TB级别，那么用1G来分页。

ZGC支持NUMA。UMA：统一内存访问，指以前cpu在访问内存时要通过总线  
NUMA：非统一内存访问，指cpu和内存被放在了一个单元上，这时cpu访问内存的速度会加快  

ZGC不用对象头来记录垃圾回收的相关信息，而是用对象指针的高位42、43、45来做GC相关的事情（42位以下表示堆空间），如快速实现垃圾回收中的并发标记、转移和重定位等。，这就是所谓的指针着色计技术。
![[Pasted image 20220713215716.png]]


# ZGC的流程
## 第一次ZGC
1、标记阶段
- 初始标记：STW，枚举GCRoot直接可达的对象；
- 并发标记：与用户线程同时进行；
- 再标记：解决并发标记过程中引用关系改变导致的漏标问题。

标记阶段结束时，所有存活对象都被标记为**绿色**。

2、转移阶段，如果是不同页面之间相当于复制算法，如果是相同页面相当于标记整理
- 并发转移准备：将垃圾较多的页面的回收优先级调高，同时如果某个页面全是垃圾则直接回收；
- 初始转移：stw，将初始标记标记的对象进行转移，并且进行重定位（把旧指针改为新指针）；
- 并发转移：转移并发标记阶段标记的对象，由于此时用户线程还在进行，不能更改旧指针指向的地址，所以引入转移表来标记新旧地址间的映射，并且转移操作和插入转移表是原子操作。此阶段结束后不进行重定位，而是交给第二次垃圾回收时做。如果此时有线程访问转移对象的旧地址，则触发读屏障，下面再讲；

3、进行第一次垃圾回收，将存活对象转移之前的老页面回收。注意第一次ZGC结束后，转移过的对象的指针（绿色）还在。

![[Pasted image 20220713214651.png]]

## 第二次ZGC
第二次垃圾回收的标记阶段，会用**红色**去标记存活对象，此时还会做上一次ZGC转移对象的**重定位**，即如果遇到绿色指针，会根据转发表将其指向新的位置（改为红色），并且删除转发表记录。改指针和删转发表是原子操作。

## 读屏障
接上面所说，如果在第一次垃圾回收后，有线程访问并发转移后还没做重定位的对象的地址（如图中的B、C），由于此时旧地址已失效，所以会触发读屏障（读屏障类似于aop，是JVM向应用代码插入一小段代码的技术），此时读屏障包含的操作是：判断当前指针不是本次GC的颜色，进行对象重定位和删除转发表记录（原子操作）。

# 优化项
![[Pasted image 20220714214203.png]]