# Serial
单线程，且在进行垃圾收集的时候必须停止其他线程；用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法；简单高效，单CPU环境下没有线程开销，仍可用在Client模式下的新生代。

![[Pasted image 20220207184833.png]]

# Parallel
多线程收集器，在发生回收时停止用户线程；用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法。JDK8默认的垃圾收集器，在内存较小时好用，内存较大时STW时间较长。

优点：吞吐量高，即垃圾收集总时长较短
缺点：STW停顿时间较长。

![[Pasted image 20220207185217.png]]

# Parnew
多线程收集器，和Parallel相似，用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法，可以和CMS配合使用。

# CMS
JDK1.5发布，旨在缩短垃圾收集的停顿时间，垃圾回收和用户线程可以并发执行，采用 “标记-清除” 算法，常用在老年代。其垃圾回收经历四个步骤：

-   初始标记：只是标记一下GC Roots能直接关联到的对象，速度很快
-   并发标记：会深入查找GC Roots关联到的对象，比较耗时
-   重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记，这个过程的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短
-   并发清除
-   并发重置：清除标记

优点：STW停顿时间较短（吞吐量较小），因为最耗时的并发标记是和用户线程一起执行的。

缺点：
- 垃圾收集总时长较长
- 耗费CPU资源（并发标记和并发清理会和用户进程抢夺资源）
- 无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理)
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数- XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理
- 可能会触发“并发失败”，即并发标记或并发清理过程中，如果又有超出了老年代剩余空间大小的对象进来，会强制stop the world，用serial old垃圾收集器来专心做垃圾回收。

![[Pasted image 20220207190103.png]]

如果初始标记过程中不STW，那么在枚举GC Root的过程中，已经被视为垃圾的对象可能会又被其他对象所引用而变为正常的对象，然后被误清除；或者标记过程中可能一直会有新的对象产生，导致GC Root的枚举无法结束。

CMS核心参数：
1. -XX:+UseConcMarkSweepGC:启用cms  
2. -XX:ConcGCThreads:并发的GC线程数  
3. -XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩整理(减少碎片)  
4. -XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一 次  
5. -XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC(默认是92，这是百分比) 6. -XX:+UseCMSInitiatingOccupancyOnly:只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设 定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整  
7. -XX:+CMSScavengeBeforeRemark:在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段  
8. -XX:+CMSParallellnitialMarkEnabled:表示在初始标记的时候多线程执行，缩短STW  
9. -XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行，缩短STW;

## CMS垃圾收集算法的实现——三色标记法
- 黑色：表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过，它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。
- 灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。
- 白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。

![[Pasted image 20220208160757.png]]

### 多标-浮动垃圾
如果在并发扫描之前，某个对象有到GCRoot的引用，但是扫描之后这个引用又被删除了，或者GCRoot被删除了，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。

另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。

### 漏标-写屏障
漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： 增量更新（IncrementalUpdate） 和原始快照（Snapshot At The Beginning，SATB）。

增量更新：就是当黑色对象插入新的指向白色对象的引用关系时（比如并发标记已经结束，一个黑色对象又插入了一个对白色对象的引用）， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。

原始快照：就是当灰色对象要删除指向白色对象的引用关系时（比如并发标记还未结束，一个灰色对象指向的白色对象还没来得及被扫描到就要被删除了）， 就将这个要删除的引用记录下来， 在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色（目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾）

以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障（类似于AOP）实现的：
```java
void oop_field_store(oop* field, oop new_value) {
    // 写屏障‐写前操作 
    pre_write_barrier(field);
    *field = new_value; 
    // 写屏障‐写后操作
    post_write_barrier(field, value); 
}
```
写屏障实现SATB：
```java
void pre_write_barrier(oop* field) {
    oop old_value = *field; // 获取旧值
    remark_set.add(old_value); // 记录原来的引用对象
}
```
写屏障实现增量更新：
```java
void post_write_barrier(oop* field, oop new_value) {
    // 记录新引用的对象
    remark_set.add(new_value);
}
```

### 卡表
GCRoot可达性分析是在年轻代进行的，但是为了避免发生年轻代对象被老年代引用这种“跨代引用”的情况，就不得不将所有老年代也纳入可达性分析的范围，大大降低了效率。

为了不全量扫描老年代，新生代引入了“卡表”这种字节数组，数组的每个元素对应着老年代一个特定大小的内存区域，称为“卡页”，如果某个卡页中有指向新生代的引用，那么这个卡页就是一个“脏页”，在做可达性分析时就会将这块区域也纳入扫描范围。

# G1
![[Pasted image 20220208174320.png]]
G1将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region。一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M。

垃圾回收的过程：
-   初始标记
-   并发标记
-   最终标记
-   筛选回收

![[Pasted image 20220208180952.png]]

优点：
-   并发回收，和用户线程同时执行，低停顿；
-   不用和其他收集器配合，独自管理新生代和老年代；
-   采用“ 标记-整理 ”算法，不会产生碎片；
-   可控的STW时间，在规定时间内优先回收价值大的区域

## YoungGC
YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills（最大停顿时间） 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC。

## MixedGC
不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC。

## Full GC
停止系统程序，然后采用单线程进行标记、清理和压缩整理，清理出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)