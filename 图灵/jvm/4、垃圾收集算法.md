# 可达性分析
通过一系列成为GC Roots的对象作为起始点向下搜索，走过的路径成为引用链，当一个对象到GC Roots没有任何引用链时，证明此对象不可用。

![](https://oscimg.oschina.net/oscnet/4208827c9ded5e1eb98c98b707e43be5f1c.jpg)

可作为GC Roots的对象包括：
-   虚拟机栈中引用的对象；
-   方法区中类静态属性（常量、静态变量）引用的对象
-   方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用
-   本地方法栈中（Native方法）引用的对象

# 垃圾收集算法
新生代：复制法

将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。

老年代：标记-整理法

![](https://oscimg.oschina.net/oscnet/553fd90fb9cf0b65b0039c12fd0589dccab.jpg)

标记-清除

![](https://oscimg.oschina.net/oscnet/0c877f584afe31a68b4c419c328f545deb3.jpg)

这种会造成大量内存碎片，所以不建议使用。

## 什么时候进入老年代？
对象优先在新生代分配，大对象直接进入老年代；

新生代发生垃圾回收时，如果另一个survival不够大，则存活对象进入老年代；

长期存活的对象进入老年代；

对象动态年龄判断
年轻代当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，存活对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)时，大于等于这批对象年龄最大值的对象，就可以直接进入老年代了。
例如Survivor区域里现在有一批对象，其中年龄1+年龄2的对象总和超过了Survivor区域的50%，此时就会把年龄2(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发的。
解决方法就是把年轻代调大。

假如一次young gc之后，一个s区有如下场景：
1.  年龄1的对象占用了33%
2.  年龄2的对象占用33%
3.  年龄3的对象占用34%

那么，年龄从小到大进行累加，当加入某个年龄段后，累加和超过survivor区域\*TargetSurvivorRatio的时候，就从这个年龄段往上的年龄的对象进行晋升。

所以上面的场景，年龄1的占用了33%，年龄2的占用了33%，累加和超过默认的TargetSurvivorRatio（50%），年龄2和年龄3的对象都要晋升。

再假如，年龄3的对象占用10%，年龄4的对象占用10%，此时新分配了一批年龄1为60%的对象，那么年龄1、3、4的对象全部进入老年代。

## 老年代空间分配担保
在发生young GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总 空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX:HandlePromotionFailure参数的设置值是否允许担保失败(Handle Promotion Failure); 如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次young GC，尽管这次young GC是有风险的;如果小于，或者
-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。

# 元空间（方法区）的回收
方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？类需要同时满足下面3个条件才能算是 “无用的类” ：
- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例
- 加载该类的 ClassLoader 已经被回收
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

能满足上述条件的类很少，所以元空间即使回收也不会释放出太多内存。

# 对象的引用关系
强引用：永远不会被回收
软引用(SoftReference)：只有内存不足时才会被回收
弱引用(WeekReference)：下一次垃圾回收时被回收
虚引用：它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目 的只是为了能在这个对象被收集器回收时收到一个系统通知。