# JVM内存模型
程序计数器：通过改变值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等都要依赖此计数器。此内存区域是唯一一个没有OutOfMemoryError的区域。

Java虚拟机栈：非线程共享，每new一个线程都会从虚拟机栈中开辟一个新的线程栈，线程每执行一个方法都会在当前线程栈中继续开辟方法对应的栈，即栈帧。方法栈中包含四个部分：局部变量表（存放方法运行期间的局部变量）、操作数栈（字节码执行时的中转内存）、动态链接（方法内部调用其他方法时将符号引用转成的指针）、方法出口（方法嵌套调用返回时恢复现场）。会抛出StackOverflowError和OutOfMemoryError。
![[Pasted image 20220204212459.png]]

方法区：用于存储已被虚拟机加载的类元信息（类的代码信息，对象头里的元数据指针KlassPoint会指向这里）、常量（String常量池也在这里）、静态变量（static变量、static方法）、即时编译器编译后的代码等数据；被各个线程共享，被GC管理，会抛出OutOfMemoryError。

Java堆：被所有线程共共享，存储所有的对象实例以及数组，被所有线程共享；java堆是垃圾收集器管理的主要区域（GC堆）；会抛出OutOfMemoryError。

本地方法栈：为Native方法服务

元空间：即原来的方法区

# new对象的过程
一、类加载-![[1、类加载#类加载过程]]
二、创建对象
1. 在堆区分配对象需要的内存（指针碰撞法或空闲列表法）
-   指针碰撞，当虚拟机使用复制算法或标记整理算法实现的垃圾收集器时，内存区域都是规整的，这时候使用指针碰撞分配内存，用过的内存放在一边，空闲的内存在另一边，中间用一个指针作为分界点，当需要为新对象分配内存时只需把指针向空闲的一边移动一段与对象大小相等的距离。
-   空闲列表，当虚拟机使用标记清除算法实现的垃圾收集器时，内存都是碎片化的，那虚拟机就要记录哪块内存是可用的，当需要分配内存时，找一块足够大的内存空间给对象实例，并更新记录。
2. 对所有实例变量赋默认值
3. 执行实例初始化代码。初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法

在分配内存时可能有并发问题，用cas或者TLAB解决。TLAB即本地线程分配缓冲，就是每个线程都会预先在堆上申请一块空间，需要new对象时每个线程就在各自的堆空间上分配。

# 对象的内存分配
![[Pasted image 20220207141818.png]]

## 逃逸分析
就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。

## 标量替换
通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解成若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。
```java
public class Point{
	int x;
	int y;
}

private static String alloc() {
	Point point = new Point(1,2);
	return point.toString();
}

public static void main(){
	int i=0;
	while(i<50000){
		alloc();
	}
}
```
以上方法中的Point对象会以标量分配的方式在栈内分配。

## 对象动态年龄判断
年轻代当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了。
例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发的。
解决方法就是把年轻代调大。

假如一次young gc之后，一个s区有如下场景：
1.  年龄1的对象占用了33%
2.  年龄2的对象占用33%
3.  年龄3的对象占用34%

那么，年龄从小到大进行累加，当加入某个年龄段后，累加和超过survivor区域\*TargetSurvivorRatio的时候，就从这个年龄段往上的年龄的对象进行晋升。

所以上面的场景，年龄1的占用了33%，年龄2的占用了33%，累加和超过默认的TargetSurvivorRatio（50%），年龄2和年龄3的对象都要晋升。

再假如，年龄3的对象占用10%，年龄4的对象占用10%，此时新分配了一批年龄1为60%的对象，那么年龄1、3、4的对象全部进入老年代。


## 老年代空间分配担保机制
![[Pasted image 20220207153220.png]]

## 元空间（方法区）的回收
方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？类需要同时满足下面3个条件才能算是 “无用的类” ：
- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例
- 加载该类的 ClassLoader 已经被回收
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

能满足上述条件的类很少，所以元空间即使回收也不会释放出太多内存。
