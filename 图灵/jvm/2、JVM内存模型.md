# JVM内存模型
程序计数器：通过改变值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等都要依赖此计数器，如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。此内存区域是唯一一个没有OutOfMemoryError的区域。在多线程环境下，每个线程都有自己的程序计数器，互不影响。

Java虚拟机栈：非线程共享，每new一个线程都会从虚拟机栈中开辟一个新的线程栈，线程每执行一个方法都会在当前线程栈中继续开辟方法对应的栈，即栈帧。方法栈中包含四个部分：局部变量表（存放方法运行期间的局部变量）、操作数栈（字节码执行时的中转内存）、动态链接（方法内部调用其他方法时将符号引用转成的指针）、方法出口（方法嵌套调用返回时恢复现场）。会抛出StackOverflowError和OutOfMemoryError。
![[Pasted image 20220204212459.png]]

Java堆：被所有线程共共享，存储所有的对象实例以及数组，被所有线程共享；java堆是垃圾收集器管理的主要区域（GC堆）；会抛出OutOfMemoryError。

方法区：用于存储已被虚拟机加载的类元信息（类的代码信息，对象头里的元数据指针KlassPoint会指向这里）、常量（String常量池也在这里）、静态变量（static变量、static方法）、即时编译器编译后的代码等数据；和堆一样被各个线程共享，被GC管理，会抛出OutOfMemoryError。JDK7以前的永久代，JDK8以后的元空间。

运行时常量池(Runtime Constant Pool)：是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与 符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。

直接内存(Direct Memory)：并不是虚拟机运行时数据区的一部分，也不 是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地 使用，而且也可能导致OutOfMemoryError异常出现。
在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通 道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库 直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据。

本地方法栈：为Native方法服务

元空间：即原来的方法区




