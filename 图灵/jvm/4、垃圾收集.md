# 垃圾收集器
## serial
单线程，且在进行垃圾收集的时候必须停止其他线程；用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法；简单高效，单CPU环境下没有线程开销，仍可用在Client模式下的新生代。

![[Pasted image 20220207184833.png]]

## Parallel
多线程收集器，在发生回收时停止用户线程；用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法。JDK8默认的垃圾收集器，在内存较小时好用，内存较大时STW时间较长。

优点：吞吐量高，即垃圾收集总时长较短
缺点：STW停顿时间较长。

![[Pasted image 20220207185217.png]]

## Parnew
多线程收集器，和Parallel相似，用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法，可以和CMS配合使用。

## CMS
JDK1.5发布，旨在缩短垃圾收集的停顿时间，垃圾回收和用户线程可以并发执行，采用 “标记-清除” 算法，常用在老年代。其垃圾回收经历四个步骤：

-   初始标记：只是标记一下GC Roots能直接关联到的对象，速度很快
-   并发标记：会深入查找GC Roots关联到的对象，比较耗时
-   重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记，这个过程的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短
-   并发清除
-   并发重置：清除标记

优点：STW停顿时间较短（吞吐量较小），因为最耗时的并发标记是和用户线程一起执行的。

缺点：
- 垃圾收集总时长较长
- 耗费CPU资源（并发标记和并发清理会和用户进程抢夺资源）
- 无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理)
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数- XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理
- 可能会触发“并发失败”，即并发标记或并发清理过程中，如果又有超出了老年代剩余空间大小的对象进来，会强制stop the world，用serial old垃圾收集器来专心做垃圾回收。

![[Pasted image 20220207190103.png]]

如果初始标记过程中不STW，那么在枚举GC Root的过程中，已经被视为垃圾的对象可能会又被其他对象所引用而变为正常的对象，然后被误清除；或者标记过程中可能一直会有新的对象产生，导致GC Root的枚举无法结束。

CMS核心参数：
1. -XX:+UseConcMarkSweepGC:启用cms  
2. -XX:ConcGCThreads:并发的GC线程数  
3. -XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩整理(减少碎片)  
4. -XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一 次  
5. -XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC(默认是92，这是百分比) 6. -XX:+UseCMSInitiatingOccupancyOnly:只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设 定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整  
7. -XX:+CMSScavengeBeforeRemark:在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段  
8. -XX:+CMSParallellnitialMarkEnabled:表示在初始标记的时候多线程执行，缩短STW  
9. -XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行，缩短STW;