# 垃圾收集器
## serial
单线程，且在进行垃圾收集的时候必须停止其他线程；用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法；简单高效，单CPU环境下没有线程开销，仍可用在Client模式下的新生代。

![[Pasted image 20220207184833.png]]

## Parallel
多线程收集器，在发生回收时停止用户线程；用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法。JDK8默认的垃圾收集器，在内存较小时好用，内存较大时STW时间较长。

![[Pasted image 20220207185217.png]]

## Parnew
多线程收集器，和Parallel相似，用在新生代时使用复制算法，用在老年代时使用 “标记-整理“ 算法，可以和CMS配合使用。

## CMS
JDK1.5发布，旨在缩短垃圾收集的停顿时间，垃圾回收和用户线程可以并发执行，采用 “标记-清除” 算法，常用在老年代。其垃圾回收经历四个步骤：

-   初始标记：只是标记一下GC Roots能直接关联到的对象，速度很快
-   并发标记：会深入查找GC Roots关联到的对象，比较耗时
-   重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记，这个过程的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短
-   并发清除
-   并发重置：清除标记

![[Pasted image 20220207190103.png]]

如果初始标记过程中不STW，那么在枚举GC Root的过程中，已经被视为垃圾的对象可能会又被其他对象所引用而变为正常的对象，然后被误清除；或者标记过程中可能一直会有新的对象产生，导致GC Root的枚举无法结束