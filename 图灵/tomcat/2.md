# 五种io模型
![[Pasted image 20220601233543.png]]

阻塞与否指的是第一阶段，同步与否指的是第二阶段

bio是同步阻塞io，nio是同步非阻塞io，aio是异步非阻塞io

## tomcat支持的io模型
![[Pasted image 20220606211419.png]]

## tomcat如何选择合适的io模型
NIO在绝大多数情况下都是够用的。如果web应用使用了TLS加密传输，而且对性能要求极高，可以使用APR，用C实现，性能比java高，但是需要手动装类库。如果tomcat跑在windows平台上，可以使用AIO，因为windows的AIO比linux的完善，linux基于epoll实现，性能与nio持平，而windows不开源。

# Tomcat Endpoint的线程模型
## NioEndpoint
单reactor+线程池
![[Pasted image 20220606213228.png]]

多reactor（主从）
![[Pasted image 20220606213328.png]]

tomcat使用的是第二种
![[Pasted image 20220609232940.png]]
LimitLatch 是连接控制器，它负责控制最大连接数，NIO 模式下默认是 10000(tomcat9中8192)，当连接数到达最大时阻塞线程，直到后续组件处理完一个 连接后将连接数减 1。注意到达最大连接数后操作系统底层还是会接收客户端连接， 但用户层已经不再接收。

Acceptor 跑在一个单独的线程里，它在一个死循环里调用 accept 方法来接收 新连接，一旦有新的连接请求到来，accept() 方法返回获得 SocketChannel 对象，然后将 SocketChannel 对象封装在一个 PollerEvent 对象中，并将PollerEvent 对象压入 Poller 的 SynchronizedQueue 里，这是个典型的生产者 - 消费者 模式，Acceptor 与 Poller 线程之间通过 SynchronizedQueue 通信。

Poller 的本质是一个 Selector，也跑在单独线程里。Poller 在内部维护一个 Channel 数组，它在一个死循环里不断检测 Channel 的数据就绪状态，一旦有 Channel 可读，就生成一个 SocketProcessor 任务对象扔给 Executor 去处理。
![[Pasted image 20220609234522.png]]
(难道不是线程池在消费poller吗，像kafka那样)